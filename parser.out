Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ALEATORIO
    COMENTARIO
    ENTRADA

Grammar

Rule 0     S' -> code
Rule 1     code -> com_list
Rule 2     com_list -> command
Rule 3     com_list -> com_list command
Rule 4     command -> e ;
Rule 5     command -> ciclo_for
Rule 6     command -> callfunc ;
Rule 7     command -> if
Rule 8     command -> func
Rule 9     command -> VARS VAR ATRIBUICAO var_list ;
Rule 10    command -> ESCREVER var_list
Rule 11    command -> ESCREVER e_list
Rule 12    ciclo_for -> PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM
Rule 13    if -> SE e ENTAO com_list FIM_SE
Rule 14    if -> SE e ENTAO com_list SENAO com_list FIM_SE
Rule 15    func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO
Rule 16    func -> FUNCAO VAR ( ) com_list FIM_FUNCAO
Rule 17    callfunc -> VAR ( e_list )
Rule 18    callfunc -> VAR ( )
Rule 19    var_fun_list -> var_fun
Rule 20    var_fun_list -> var_fun_list , var_fun
Rule 21    var_fun -> type VAR
Rule 22    var_list -> VAR
Rule 23    var_list -> var_list , VAR
Rule 24    e_list -> e
Rule 25    e_list -> e_list , e
Rule 26    e -> REAL
Rule 27    e -> INTEIRO
Rule 28    e -> CARACTER
Rule 29    e -> condicao
Rule 30    e -> - e
Rule 31    e -> e * e
Rule 32    e -> e / e
Rule 33    e -> e + e
Rule 34    e -> e - e
Rule 35    e -> logico
Rule 36    e -> e OR e
Rule 37    e -> e AND e
Rule 38    e -> e XOR e
Rule 39    e -> ( e )
Rule 40    e -> VAR
Rule 41    condicao -> e SMALLER e
Rule 42    condicao -> e SMALLER_EQUAL e
Rule 43    condicao -> e BIGGER e
Rule 44    condicao -> e BIGGER_EQUAL e
Rule 45    condicao -> e EQUAL e
Rule 46    condicao -> e NOT_EQUAL e
Rule 47    type -> DEFINITION_INTEIRO
Rule 48    type -> DEFINITION_REAL
Rule 49    type -> DEFINITION_CARACTER
Rule 50    type -> DEFENITION_LOGICO
Rule 51    logico -> TRUE
Rule 52    logico -> FALSE
Rule 53    logico -> NOT logico

Terminals, with rules where they appear

(                    : 15 16 17 18 39
)                    : 15 16 17 18 39
*                    : 31
+                    : 33
,                    : 20 23 25
-                    : 30 34
/                    : 32
;                    : 4 6 9
ALEATORIO            : 
AND                  : 37
ATRIBUICAO           : 9
BIGGER               : 43
BIGGER_EQUAL         : 44
CARACTER             : 28
COMENTARIO           : 
DEFENITION_LOGICO    : 50
DEFINITION_CARACTER  : 49
DEFINITION_INTEIRO   : 47
DEFINITION_REAL      : 48
ELIPSIS              : 12
EM                   : 12
ENTAO                : 13 14
ENTRADA              : 
EQUAL                : 45
ESCREVER             : 10 11
FALSE                : 52
FAZER                : 12
FIM                  : 12
FIM_FUNCAO           : 15 16
FIM_SE               : 13 14
FUNCAO               : 15 16
INTEIRO              : 12 12 27
NOT                  : 53
NOT_EQUAL            : 46
OR                   : 36
PARA                 : 12
REAL                 : 26
SE                   : 13 14
SENAO                : 14
SMALLER              : 41
SMALLER_EQUAL        : 42
TRUE                 : 51
VAR                  : 9 15 16 17 18 21 22 23 40
VARS                 : 9 12
XOR                  : 38
[                    : 12
]                    : 12
error                : 

Nonterminals, with rules where they appear

callfunc             : 6
ciclo_for            : 5
code                 : 0
com_list             : 1 3 12 13 14 14 15 16
command              : 2 3
condicao             : 29
e                    : 4 13 14 24 25 30 31 31 32 32 33 33 34 34 36 36 37 37 38 38 39 41 41 42 42 43 43 44 44 45 45 46 46
e_list               : 11 17 25
func                 : 8
if                   : 7
logico               : 35 53
type                 : 21
var_fun              : 19 20
var_fun_list         : 15 20
var_list             : 9 10 23

Parsing method: LALR

state 0

    (0) S' -> . code
    (1) code -> . com_list
    (2) com_list -> . command
    (3) com_list -> . com_list command
    (4) command -> . e ;
    (5) command -> . ciclo_for
    (6) command -> . callfunc ;
    (7) command -> . if
    (8) command -> . func
    (9) command -> . VARS VAR ATRIBUICAO var_list ;
    (10) command -> . ESCREVER var_list
    (11) command -> . ESCREVER e_list
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (12) ciclo_for -> . PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM
    (17) callfunc -> . VAR ( e_list )
    (18) callfunc -> . VAR ( )
    (13) if -> . SE e ENTAO com_list FIM_SE
    (14) if -> . SE e ENTAO com_list SENAO com_list FIM_SE
    (15) func -> . FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO
    (16) func -> . FUNCAO VAR ( ) com_list FIM_FUNCAO
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    VARS            shift and go to state 9
    ESCREVER        shift and go to state 11
    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 10
    PARA            shift and go to state 19
    SE              shift and go to state 20
    FUNCAO          shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    code                           shift and go to state 1
    com_list                       shift and go to state 2
    command                        shift and go to state 3
    e                              shift and go to state 4
    ciclo_for                      shift and go to state 5
    callfunc                       shift and go to state 6
    if                             shift and go to state 7
    func                           shift and go to state 8
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 1

    (0) S' -> code .



state 2

    (1) code -> com_list .
    (3) com_list -> com_list . command
    (4) command -> . e ;
    (5) command -> . ciclo_for
    (6) command -> . callfunc ;
    (7) command -> . if
    (8) command -> . func
    (9) command -> . VARS VAR ATRIBUICAO var_list ;
    (10) command -> . ESCREVER var_list
    (11) command -> . ESCREVER e_list
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (12) ciclo_for -> . PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM
    (17) callfunc -> . VAR ( e_list )
    (18) callfunc -> . VAR ( )
    (13) if -> . SE e ENTAO com_list FIM_SE
    (14) if -> . SE e ENTAO com_list SENAO com_list FIM_SE
    (15) func -> . FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO
    (16) func -> . FUNCAO VAR ( ) com_list FIM_FUNCAO
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    $end            reduce using rule 1 (code -> com_list .)
    VARS            shift and go to state 9
    ESCREVER        shift and go to state 11
    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 10
    PARA            shift and go to state 19
    SE              shift and go to state 20
    FUNCAO          shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    command                        shift and go to state 25
    e                              shift and go to state 4
    ciclo_for                      shift and go to state 5
    callfunc                       shift and go to state 6
    if                             shift and go to state 7
    func                           shift and go to state 8
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 3

    (2) com_list -> command .

    VARS            reduce using rule 2 (com_list -> command .)
    ESCREVER        reduce using rule 2 (com_list -> command .)
    REAL            reduce using rule 2 (com_list -> command .)
    INTEIRO         reduce using rule 2 (com_list -> command .)
    CARACTER        reduce using rule 2 (com_list -> command .)
    -               reduce using rule 2 (com_list -> command .)
    (               reduce using rule 2 (com_list -> command .)
    VAR             reduce using rule 2 (com_list -> command .)
    PARA            reduce using rule 2 (com_list -> command .)
    SE              reduce using rule 2 (com_list -> command .)
    FUNCAO          reduce using rule 2 (com_list -> command .)
    TRUE            reduce using rule 2 (com_list -> command .)
    FALSE           reduce using rule 2 (com_list -> command .)
    NOT             reduce using rule 2 (com_list -> command .)
    $end            reduce using rule 2 (com_list -> command .)
    FIM_SE          reduce using rule 2 (com_list -> command .)
    SENAO           reduce using rule 2 (com_list -> command .)
    FIM_FUNCAO      reduce using rule 2 (com_list -> command .)
    FIM             reduce using rule 2 (com_list -> command .)


state 4

    (4) command -> e . ;
    (31) e -> e . * e
    (32) e -> e . / e
    (33) e -> e . + e
    (34) e -> e . - e
    (36) e -> e . OR e
    (37) e -> e . AND e
    (38) e -> e . XOR e
    (41) condicao -> e . SMALLER e
    (42) condicao -> e . SMALLER_EQUAL e
    (43) condicao -> e . BIGGER e
    (44) condicao -> e . BIGGER_EQUAL e
    (45) condicao -> e . EQUAL e
    (46) condicao -> e . NOT_EQUAL e

    ;               shift and go to state 26
    *               shift and go to state 27
    /               shift and go to state 28
    +               shift and go to state 29
    -               shift and go to state 30
    OR              shift and go to state 31
    AND             shift and go to state 32
    XOR             shift and go to state 33
    SMALLER         shift and go to state 34
    SMALLER_EQUAL   shift and go to state 35
    BIGGER          shift and go to state 36
    BIGGER_EQUAL    shift and go to state 37
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39


state 5

    (5) command -> ciclo_for .

    VARS            reduce using rule 5 (command -> ciclo_for .)
    ESCREVER        reduce using rule 5 (command -> ciclo_for .)
    REAL            reduce using rule 5 (command -> ciclo_for .)
    INTEIRO         reduce using rule 5 (command -> ciclo_for .)
    CARACTER        reduce using rule 5 (command -> ciclo_for .)
    -               reduce using rule 5 (command -> ciclo_for .)
    (               reduce using rule 5 (command -> ciclo_for .)
    VAR             reduce using rule 5 (command -> ciclo_for .)
    PARA            reduce using rule 5 (command -> ciclo_for .)
    SE              reduce using rule 5 (command -> ciclo_for .)
    FUNCAO          reduce using rule 5 (command -> ciclo_for .)
    TRUE            reduce using rule 5 (command -> ciclo_for .)
    FALSE           reduce using rule 5 (command -> ciclo_for .)
    NOT             reduce using rule 5 (command -> ciclo_for .)
    $end            reduce using rule 5 (command -> ciclo_for .)
    FIM_SE          reduce using rule 5 (command -> ciclo_for .)
    SENAO           reduce using rule 5 (command -> ciclo_for .)
    FIM_FUNCAO      reduce using rule 5 (command -> ciclo_for .)
    FIM             reduce using rule 5 (command -> ciclo_for .)


state 6

    (6) command -> callfunc . ;

    ;               shift and go to state 40


state 7

    (7) command -> if .

    VARS            reduce using rule 7 (command -> if .)
    ESCREVER        reduce using rule 7 (command -> if .)
    REAL            reduce using rule 7 (command -> if .)
    INTEIRO         reduce using rule 7 (command -> if .)
    CARACTER        reduce using rule 7 (command -> if .)
    -               reduce using rule 7 (command -> if .)
    (               reduce using rule 7 (command -> if .)
    VAR             reduce using rule 7 (command -> if .)
    PARA            reduce using rule 7 (command -> if .)
    SE              reduce using rule 7 (command -> if .)
    FUNCAO          reduce using rule 7 (command -> if .)
    TRUE            reduce using rule 7 (command -> if .)
    FALSE           reduce using rule 7 (command -> if .)
    NOT             reduce using rule 7 (command -> if .)
    $end            reduce using rule 7 (command -> if .)
    FIM_SE          reduce using rule 7 (command -> if .)
    SENAO           reduce using rule 7 (command -> if .)
    FIM_FUNCAO      reduce using rule 7 (command -> if .)
    FIM             reduce using rule 7 (command -> if .)


state 8

    (8) command -> func .

    VARS            reduce using rule 8 (command -> func .)
    ESCREVER        reduce using rule 8 (command -> func .)
    REAL            reduce using rule 8 (command -> func .)
    INTEIRO         reduce using rule 8 (command -> func .)
    CARACTER        reduce using rule 8 (command -> func .)
    -               reduce using rule 8 (command -> func .)
    (               reduce using rule 8 (command -> func .)
    VAR             reduce using rule 8 (command -> func .)
    PARA            reduce using rule 8 (command -> func .)
    SE              reduce using rule 8 (command -> func .)
    FUNCAO          reduce using rule 8 (command -> func .)
    TRUE            reduce using rule 8 (command -> func .)
    FALSE           reduce using rule 8 (command -> func .)
    NOT             reduce using rule 8 (command -> func .)
    $end            reduce using rule 8 (command -> func .)
    FIM_SE          reduce using rule 8 (command -> func .)
    SENAO           reduce using rule 8 (command -> func .)
    FIM_FUNCAO      reduce using rule 8 (command -> func .)
    FIM             reduce using rule 8 (command -> func .)


state 9

    (9) command -> VARS . VAR ATRIBUICAO var_list ;

    VAR             shift and go to state 41


state 10

    (40) e -> VAR .
    (17) callfunc -> VAR . ( e_list )
    (18) callfunc -> VAR . ( )

    ;               reduce using rule 40 (e -> VAR .)
    *               reduce using rule 40 (e -> VAR .)
    /               reduce using rule 40 (e -> VAR .)
    +               reduce using rule 40 (e -> VAR .)
    -               reduce using rule 40 (e -> VAR .)
    OR              reduce using rule 40 (e -> VAR .)
    AND             reduce using rule 40 (e -> VAR .)
    XOR             reduce using rule 40 (e -> VAR .)
    SMALLER         reduce using rule 40 (e -> VAR .)
    SMALLER_EQUAL   reduce using rule 40 (e -> VAR .)
    BIGGER          reduce using rule 40 (e -> VAR .)
    BIGGER_EQUAL    reduce using rule 40 (e -> VAR .)
    EQUAL           reduce using rule 40 (e -> VAR .)
    NOT_EQUAL       reduce using rule 40 (e -> VAR .)
    (               shift and go to state 42


state 11

    (10) command -> ESCREVER . var_list
    (11) command -> ESCREVER . e_list
    (22) var_list -> . VAR
    (23) var_list -> . var_list , VAR
    (24) e_list -> . e
    (25) e_list -> . e_list , e
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    VAR             shift and go to state 45
    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    var_list                       shift and go to state 43
    e_list                         shift and go to state 44
    e                              shift and go to state 46
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 12

    (26) e -> REAL .

    ;               reduce using rule 26 (e -> REAL .)
    *               reduce using rule 26 (e -> REAL .)
    /               reduce using rule 26 (e -> REAL .)
    +               reduce using rule 26 (e -> REAL .)
    -               reduce using rule 26 (e -> REAL .)
    OR              reduce using rule 26 (e -> REAL .)
    AND             reduce using rule 26 (e -> REAL .)
    XOR             reduce using rule 26 (e -> REAL .)
    SMALLER         reduce using rule 26 (e -> REAL .)
    SMALLER_EQUAL   reduce using rule 26 (e -> REAL .)
    BIGGER          reduce using rule 26 (e -> REAL .)
    BIGGER_EQUAL    reduce using rule 26 (e -> REAL .)
    EQUAL           reduce using rule 26 (e -> REAL .)
    NOT_EQUAL       reduce using rule 26 (e -> REAL .)
    ,               reduce using rule 26 (e -> REAL .)
    VARS            reduce using rule 26 (e -> REAL .)
    ESCREVER        reduce using rule 26 (e -> REAL .)
    REAL            reduce using rule 26 (e -> REAL .)
    INTEIRO         reduce using rule 26 (e -> REAL .)
    CARACTER        reduce using rule 26 (e -> REAL .)
    (               reduce using rule 26 (e -> REAL .)
    VAR             reduce using rule 26 (e -> REAL .)
    PARA            reduce using rule 26 (e -> REAL .)
    SE              reduce using rule 26 (e -> REAL .)
    FUNCAO          reduce using rule 26 (e -> REAL .)
    TRUE            reduce using rule 26 (e -> REAL .)
    FALSE           reduce using rule 26 (e -> REAL .)
    NOT             reduce using rule 26 (e -> REAL .)
    $end            reduce using rule 26 (e -> REAL .)
    FIM_SE          reduce using rule 26 (e -> REAL .)
    SENAO           reduce using rule 26 (e -> REAL .)
    FIM_FUNCAO      reduce using rule 26 (e -> REAL .)
    FIM             reduce using rule 26 (e -> REAL .)
    )               reduce using rule 26 (e -> REAL .)
    ENTAO           reduce using rule 26 (e -> REAL .)


state 13

    (27) e -> INTEIRO .

    ;               reduce using rule 27 (e -> INTEIRO .)
    *               reduce using rule 27 (e -> INTEIRO .)
    /               reduce using rule 27 (e -> INTEIRO .)
    +               reduce using rule 27 (e -> INTEIRO .)
    -               reduce using rule 27 (e -> INTEIRO .)
    OR              reduce using rule 27 (e -> INTEIRO .)
    AND             reduce using rule 27 (e -> INTEIRO .)
    XOR             reduce using rule 27 (e -> INTEIRO .)
    SMALLER         reduce using rule 27 (e -> INTEIRO .)
    SMALLER_EQUAL   reduce using rule 27 (e -> INTEIRO .)
    BIGGER          reduce using rule 27 (e -> INTEIRO .)
    BIGGER_EQUAL    reduce using rule 27 (e -> INTEIRO .)
    EQUAL           reduce using rule 27 (e -> INTEIRO .)
    NOT_EQUAL       reduce using rule 27 (e -> INTEIRO .)
    ,               reduce using rule 27 (e -> INTEIRO .)
    VARS            reduce using rule 27 (e -> INTEIRO .)
    ESCREVER        reduce using rule 27 (e -> INTEIRO .)
    REAL            reduce using rule 27 (e -> INTEIRO .)
    INTEIRO         reduce using rule 27 (e -> INTEIRO .)
    CARACTER        reduce using rule 27 (e -> INTEIRO .)
    (               reduce using rule 27 (e -> INTEIRO .)
    VAR             reduce using rule 27 (e -> INTEIRO .)
    PARA            reduce using rule 27 (e -> INTEIRO .)
    SE              reduce using rule 27 (e -> INTEIRO .)
    FUNCAO          reduce using rule 27 (e -> INTEIRO .)
    TRUE            reduce using rule 27 (e -> INTEIRO .)
    FALSE           reduce using rule 27 (e -> INTEIRO .)
    NOT             reduce using rule 27 (e -> INTEIRO .)
    $end            reduce using rule 27 (e -> INTEIRO .)
    FIM_SE          reduce using rule 27 (e -> INTEIRO .)
    SENAO           reduce using rule 27 (e -> INTEIRO .)
    FIM_FUNCAO      reduce using rule 27 (e -> INTEIRO .)
    FIM             reduce using rule 27 (e -> INTEIRO .)
    )               reduce using rule 27 (e -> INTEIRO .)
    ENTAO           reduce using rule 27 (e -> INTEIRO .)


state 14

    (28) e -> CARACTER .

    ;               reduce using rule 28 (e -> CARACTER .)
    *               reduce using rule 28 (e -> CARACTER .)
    /               reduce using rule 28 (e -> CARACTER .)
    +               reduce using rule 28 (e -> CARACTER .)
    -               reduce using rule 28 (e -> CARACTER .)
    OR              reduce using rule 28 (e -> CARACTER .)
    AND             reduce using rule 28 (e -> CARACTER .)
    XOR             reduce using rule 28 (e -> CARACTER .)
    SMALLER         reduce using rule 28 (e -> CARACTER .)
    SMALLER_EQUAL   reduce using rule 28 (e -> CARACTER .)
    BIGGER          reduce using rule 28 (e -> CARACTER .)
    BIGGER_EQUAL    reduce using rule 28 (e -> CARACTER .)
    EQUAL           reduce using rule 28 (e -> CARACTER .)
    NOT_EQUAL       reduce using rule 28 (e -> CARACTER .)
    ,               reduce using rule 28 (e -> CARACTER .)
    VARS            reduce using rule 28 (e -> CARACTER .)
    ESCREVER        reduce using rule 28 (e -> CARACTER .)
    REAL            reduce using rule 28 (e -> CARACTER .)
    INTEIRO         reduce using rule 28 (e -> CARACTER .)
    CARACTER        reduce using rule 28 (e -> CARACTER .)
    (               reduce using rule 28 (e -> CARACTER .)
    VAR             reduce using rule 28 (e -> CARACTER .)
    PARA            reduce using rule 28 (e -> CARACTER .)
    SE              reduce using rule 28 (e -> CARACTER .)
    FUNCAO          reduce using rule 28 (e -> CARACTER .)
    TRUE            reduce using rule 28 (e -> CARACTER .)
    FALSE           reduce using rule 28 (e -> CARACTER .)
    NOT             reduce using rule 28 (e -> CARACTER .)
    $end            reduce using rule 28 (e -> CARACTER .)
    FIM_SE          reduce using rule 28 (e -> CARACTER .)
    SENAO           reduce using rule 28 (e -> CARACTER .)
    FIM_FUNCAO      reduce using rule 28 (e -> CARACTER .)
    FIM             reduce using rule 28 (e -> CARACTER .)
    )               reduce using rule 28 (e -> CARACTER .)
    ENTAO           reduce using rule 28 (e -> CARACTER .)


state 15

    (29) e -> condicao .

    ;               reduce using rule 29 (e -> condicao .)
    *               reduce using rule 29 (e -> condicao .)
    /               reduce using rule 29 (e -> condicao .)
    +               reduce using rule 29 (e -> condicao .)
    -               reduce using rule 29 (e -> condicao .)
    OR              reduce using rule 29 (e -> condicao .)
    AND             reduce using rule 29 (e -> condicao .)
    XOR             reduce using rule 29 (e -> condicao .)
    SMALLER         reduce using rule 29 (e -> condicao .)
    SMALLER_EQUAL   reduce using rule 29 (e -> condicao .)
    BIGGER          reduce using rule 29 (e -> condicao .)
    BIGGER_EQUAL    reduce using rule 29 (e -> condicao .)
    EQUAL           reduce using rule 29 (e -> condicao .)
    NOT_EQUAL       reduce using rule 29 (e -> condicao .)
    ,               reduce using rule 29 (e -> condicao .)
    VARS            reduce using rule 29 (e -> condicao .)
    ESCREVER        reduce using rule 29 (e -> condicao .)
    REAL            reduce using rule 29 (e -> condicao .)
    INTEIRO         reduce using rule 29 (e -> condicao .)
    CARACTER        reduce using rule 29 (e -> condicao .)
    (               reduce using rule 29 (e -> condicao .)
    VAR             reduce using rule 29 (e -> condicao .)
    PARA            reduce using rule 29 (e -> condicao .)
    SE              reduce using rule 29 (e -> condicao .)
    FUNCAO          reduce using rule 29 (e -> condicao .)
    TRUE            reduce using rule 29 (e -> condicao .)
    FALSE           reduce using rule 29 (e -> condicao .)
    NOT             reduce using rule 29 (e -> condicao .)
    $end            reduce using rule 29 (e -> condicao .)
    FIM_SE          reduce using rule 29 (e -> condicao .)
    SENAO           reduce using rule 29 (e -> condicao .)
    FIM_FUNCAO      reduce using rule 29 (e -> condicao .)
    FIM             reduce using rule 29 (e -> condicao .)
    )               reduce using rule 29 (e -> condicao .)
    ENTAO           reduce using rule 29 (e -> condicao .)


state 16

    (30) e -> - . e
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 48
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    e                              shift and go to state 47
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 17

    (35) e -> logico .

    ;               reduce using rule 35 (e -> logico .)
    *               reduce using rule 35 (e -> logico .)
    /               reduce using rule 35 (e -> logico .)
    +               reduce using rule 35 (e -> logico .)
    -               reduce using rule 35 (e -> logico .)
    OR              reduce using rule 35 (e -> logico .)
    AND             reduce using rule 35 (e -> logico .)
    XOR             reduce using rule 35 (e -> logico .)
    SMALLER         reduce using rule 35 (e -> logico .)
    SMALLER_EQUAL   reduce using rule 35 (e -> logico .)
    BIGGER          reduce using rule 35 (e -> logico .)
    BIGGER_EQUAL    reduce using rule 35 (e -> logico .)
    EQUAL           reduce using rule 35 (e -> logico .)
    NOT_EQUAL       reduce using rule 35 (e -> logico .)
    ,               reduce using rule 35 (e -> logico .)
    VARS            reduce using rule 35 (e -> logico .)
    ESCREVER        reduce using rule 35 (e -> logico .)
    REAL            reduce using rule 35 (e -> logico .)
    INTEIRO         reduce using rule 35 (e -> logico .)
    CARACTER        reduce using rule 35 (e -> logico .)
    (               reduce using rule 35 (e -> logico .)
    VAR             reduce using rule 35 (e -> logico .)
    PARA            reduce using rule 35 (e -> logico .)
    SE              reduce using rule 35 (e -> logico .)
    FUNCAO          reduce using rule 35 (e -> logico .)
    TRUE            reduce using rule 35 (e -> logico .)
    FALSE           reduce using rule 35 (e -> logico .)
    NOT             reduce using rule 35 (e -> logico .)
    $end            reduce using rule 35 (e -> logico .)
    FIM_SE          reduce using rule 35 (e -> logico .)
    SENAO           reduce using rule 35 (e -> logico .)
    FIM_FUNCAO      reduce using rule 35 (e -> logico .)
    FIM             reduce using rule 35 (e -> logico .)
    )               reduce using rule 35 (e -> logico .)
    ENTAO           reduce using rule 35 (e -> logico .)


state 18

    (39) e -> ( . e )
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 48
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    e                              shift and go to state 49
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 19

    (12) ciclo_for -> PARA . VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM

    VARS            shift and go to state 50


state 20

    (13) if -> SE . e ENTAO com_list FIM_SE
    (14) if -> SE . e ENTAO com_list SENAO com_list FIM_SE
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 48
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    e                              shift and go to state 51
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 21

    (15) func -> FUNCAO . VAR ( var_fun_list ) com_list FIM_FUNCAO
    (16) func -> FUNCAO . VAR ( ) com_list FIM_FUNCAO

    VAR             shift and go to state 52


state 22

    (51) logico -> TRUE .

    ;               reduce using rule 51 (logico -> TRUE .)
    *               reduce using rule 51 (logico -> TRUE .)
    /               reduce using rule 51 (logico -> TRUE .)
    +               reduce using rule 51 (logico -> TRUE .)
    -               reduce using rule 51 (logico -> TRUE .)
    OR              reduce using rule 51 (logico -> TRUE .)
    AND             reduce using rule 51 (logico -> TRUE .)
    XOR             reduce using rule 51 (logico -> TRUE .)
    SMALLER         reduce using rule 51 (logico -> TRUE .)
    SMALLER_EQUAL   reduce using rule 51 (logico -> TRUE .)
    BIGGER          reduce using rule 51 (logico -> TRUE .)
    BIGGER_EQUAL    reduce using rule 51 (logico -> TRUE .)
    EQUAL           reduce using rule 51 (logico -> TRUE .)
    NOT_EQUAL       reduce using rule 51 (logico -> TRUE .)
    ,               reduce using rule 51 (logico -> TRUE .)
    VARS            reduce using rule 51 (logico -> TRUE .)
    ESCREVER        reduce using rule 51 (logico -> TRUE .)
    REAL            reduce using rule 51 (logico -> TRUE .)
    INTEIRO         reduce using rule 51 (logico -> TRUE .)
    CARACTER        reduce using rule 51 (logico -> TRUE .)
    (               reduce using rule 51 (logico -> TRUE .)
    VAR             reduce using rule 51 (logico -> TRUE .)
    PARA            reduce using rule 51 (logico -> TRUE .)
    SE              reduce using rule 51 (logico -> TRUE .)
    FUNCAO          reduce using rule 51 (logico -> TRUE .)
    TRUE            reduce using rule 51 (logico -> TRUE .)
    FALSE           reduce using rule 51 (logico -> TRUE .)
    NOT             reduce using rule 51 (logico -> TRUE .)
    $end            reduce using rule 51 (logico -> TRUE .)
    FIM_SE          reduce using rule 51 (logico -> TRUE .)
    SENAO           reduce using rule 51 (logico -> TRUE .)
    FIM_FUNCAO      reduce using rule 51 (logico -> TRUE .)
    FIM             reduce using rule 51 (logico -> TRUE .)
    )               reduce using rule 51 (logico -> TRUE .)
    ENTAO           reduce using rule 51 (logico -> TRUE .)


state 23

    (52) logico -> FALSE .

    ;               reduce using rule 52 (logico -> FALSE .)
    *               reduce using rule 52 (logico -> FALSE .)
    /               reduce using rule 52 (logico -> FALSE .)
    +               reduce using rule 52 (logico -> FALSE .)
    -               reduce using rule 52 (logico -> FALSE .)
    OR              reduce using rule 52 (logico -> FALSE .)
    AND             reduce using rule 52 (logico -> FALSE .)
    XOR             reduce using rule 52 (logico -> FALSE .)
    SMALLER         reduce using rule 52 (logico -> FALSE .)
    SMALLER_EQUAL   reduce using rule 52 (logico -> FALSE .)
    BIGGER          reduce using rule 52 (logico -> FALSE .)
    BIGGER_EQUAL    reduce using rule 52 (logico -> FALSE .)
    EQUAL           reduce using rule 52 (logico -> FALSE .)
    NOT_EQUAL       reduce using rule 52 (logico -> FALSE .)
    ,               reduce using rule 52 (logico -> FALSE .)
    VARS            reduce using rule 52 (logico -> FALSE .)
    ESCREVER        reduce using rule 52 (logico -> FALSE .)
    REAL            reduce using rule 52 (logico -> FALSE .)
    INTEIRO         reduce using rule 52 (logico -> FALSE .)
    CARACTER        reduce using rule 52 (logico -> FALSE .)
    (               reduce using rule 52 (logico -> FALSE .)
    VAR             reduce using rule 52 (logico -> FALSE .)
    PARA            reduce using rule 52 (logico -> FALSE .)
    SE              reduce using rule 52 (logico -> FALSE .)
    FUNCAO          reduce using rule 52 (logico -> FALSE .)
    TRUE            reduce using rule 52 (logico -> FALSE .)
    FALSE           reduce using rule 52 (logico -> FALSE .)
    NOT             reduce using rule 52 (logico -> FALSE .)
    $end            reduce using rule 52 (logico -> FALSE .)
    FIM_SE          reduce using rule 52 (logico -> FALSE .)
    SENAO           reduce using rule 52 (logico -> FALSE .)
    FIM_FUNCAO      reduce using rule 52 (logico -> FALSE .)
    FIM             reduce using rule 52 (logico -> FALSE .)
    )               reduce using rule 52 (logico -> FALSE .)
    ENTAO           reduce using rule 52 (logico -> FALSE .)


state 24

    (53) logico -> NOT . logico
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    logico                         shift and go to state 53

state 25

    (3) com_list -> com_list command .

    VARS            reduce using rule 3 (com_list -> com_list command .)
    ESCREVER        reduce using rule 3 (com_list -> com_list command .)
    REAL            reduce using rule 3 (com_list -> com_list command .)
    INTEIRO         reduce using rule 3 (com_list -> com_list command .)
    CARACTER        reduce using rule 3 (com_list -> com_list command .)
    -               reduce using rule 3 (com_list -> com_list command .)
    (               reduce using rule 3 (com_list -> com_list command .)
    VAR             reduce using rule 3 (com_list -> com_list command .)
    PARA            reduce using rule 3 (com_list -> com_list command .)
    SE              reduce using rule 3 (com_list -> com_list command .)
    FUNCAO          reduce using rule 3 (com_list -> com_list command .)
    TRUE            reduce using rule 3 (com_list -> com_list command .)
    FALSE           reduce using rule 3 (com_list -> com_list command .)
    NOT             reduce using rule 3 (com_list -> com_list command .)
    $end            reduce using rule 3 (com_list -> com_list command .)
    FIM_SE          reduce using rule 3 (com_list -> com_list command .)
    SENAO           reduce using rule 3 (com_list -> com_list command .)
    FIM_FUNCAO      reduce using rule 3 (com_list -> com_list command .)
    FIM             reduce using rule 3 (com_list -> com_list command .)


state 26

    (4) command -> e ; .

    VARS            reduce using rule 4 (command -> e ; .)
    ESCREVER        reduce using rule 4 (command -> e ; .)
    REAL            reduce using rule 4 (command -> e ; .)
    INTEIRO         reduce using rule 4 (command -> e ; .)
    CARACTER        reduce using rule 4 (command -> e ; .)
    -               reduce using rule 4 (command -> e ; .)
    (               reduce using rule 4 (command -> e ; .)
    VAR             reduce using rule 4 (command -> e ; .)
    PARA            reduce using rule 4 (command -> e ; .)
    SE              reduce using rule 4 (command -> e ; .)
    FUNCAO          reduce using rule 4 (command -> e ; .)
    TRUE            reduce using rule 4 (command -> e ; .)
    FALSE           reduce using rule 4 (command -> e ; .)
    NOT             reduce using rule 4 (command -> e ; .)
    $end            reduce using rule 4 (command -> e ; .)
    FIM_SE          reduce using rule 4 (command -> e ; .)
    SENAO           reduce using rule 4 (command -> e ; .)
    FIM_FUNCAO      reduce using rule 4 (command -> e ; .)
    FIM             reduce using rule 4 (command -> e ; .)


state 27

    (31) e -> e * . e
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 48
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    e                              shift and go to state 54
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 28

    (32) e -> e / . e
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 48
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    e                              shift and go to state 55
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 29

    (33) e -> e + . e
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 48
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    e                              shift and go to state 56
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 30

    (34) e -> e - . e
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 48
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    e                              shift and go to state 57
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 31

    (36) e -> e OR . e
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 48
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    e                              shift and go to state 58
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 32

    (37) e -> e AND . e
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 48
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    e                              shift and go to state 59
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 33

    (38) e -> e XOR . e
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 48
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    e                              shift and go to state 60
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 34

    (41) condicao -> e SMALLER . e
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 48
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    e                              shift and go to state 61
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 35

    (42) condicao -> e SMALLER_EQUAL . e
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 48
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    e                              shift and go to state 62
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 36

    (43) condicao -> e BIGGER . e
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 48
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    e                              shift and go to state 63
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 37

    (44) condicao -> e BIGGER_EQUAL . e
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 48
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    e                              shift and go to state 64
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 38

    (45) condicao -> e EQUAL . e
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 48
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    e                              shift and go to state 65
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 39

    (46) condicao -> e NOT_EQUAL . e
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 48
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    e                              shift and go to state 66
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 40

    (6) command -> callfunc ; .

    VARS            reduce using rule 6 (command -> callfunc ; .)
    ESCREVER        reduce using rule 6 (command -> callfunc ; .)
    REAL            reduce using rule 6 (command -> callfunc ; .)
    INTEIRO         reduce using rule 6 (command -> callfunc ; .)
    CARACTER        reduce using rule 6 (command -> callfunc ; .)
    -               reduce using rule 6 (command -> callfunc ; .)
    (               reduce using rule 6 (command -> callfunc ; .)
    VAR             reduce using rule 6 (command -> callfunc ; .)
    PARA            reduce using rule 6 (command -> callfunc ; .)
    SE              reduce using rule 6 (command -> callfunc ; .)
    FUNCAO          reduce using rule 6 (command -> callfunc ; .)
    TRUE            reduce using rule 6 (command -> callfunc ; .)
    FALSE           reduce using rule 6 (command -> callfunc ; .)
    NOT             reduce using rule 6 (command -> callfunc ; .)
    $end            reduce using rule 6 (command -> callfunc ; .)
    FIM_SE          reduce using rule 6 (command -> callfunc ; .)
    SENAO           reduce using rule 6 (command -> callfunc ; .)
    FIM_FUNCAO      reduce using rule 6 (command -> callfunc ; .)
    FIM             reduce using rule 6 (command -> callfunc ; .)


state 41

    (9) command -> VARS VAR . ATRIBUICAO var_list ;

    ATRIBUICAO      shift and go to state 67


state 42

    (17) callfunc -> VAR ( . e_list )
    (18) callfunc -> VAR ( . )
    (24) e_list -> . e
    (25) e_list -> . e_list , e
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    )               shift and go to state 69
    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 48
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    e_list                         shift and go to state 68
    e                              shift and go to state 46
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 43

    (10) command -> ESCREVER var_list .
    (23) var_list -> var_list . , VAR

    VARS            reduce using rule 10 (command -> ESCREVER var_list .)
    ESCREVER        reduce using rule 10 (command -> ESCREVER var_list .)
    REAL            reduce using rule 10 (command -> ESCREVER var_list .)
    INTEIRO         reduce using rule 10 (command -> ESCREVER var_list .)
    CARACTER        reduce using rule 10 (command -> ESCREVER var_list .)
    -               reduce using rule 10 (command -> ESCREVER var_list .)
    (               reduce using rule 10 (command -> ESCREVER var_list .)
    VAR             reduce using rule 10 (command -> ESCREVER var_list .)
    PARA            reduce using rule 10 (command -> ESCREVER var_list .)
    SE              reduce using rule 10 (command -> ESCREVER var_list .)
    FUNCAO          reduce using rule 10 (command -> ESCREVER var_list .)
    TRUE            reduce using rule 10 (command -> ESCREVER var_list .)
    FALSE           reduce using rule 10 (command -> ESCREVER var_list .)
    NOT             reduce using rule 10 (command -> ESCREVER var_list .)
    $end            reduce using rule 10 (command -> ESCREVER var_list .)
    FIM_SE          reduce using rule 10 (command -> ESCREVER var_list .)
    SENAO           reduce using rule 10 (command -> ESCREVER var_list .)
    FIM_FUNCAO      reduce using rule 10 (command -> ESCREVER var_list .)
    FIM             reduce using rule 10 (command -> ESCREVER var_list .)
    ,               shift and go to state 70


state 44

    (11) command -> ESCREVER e_list .
    (25) e_list -> e_list . , e

    VARS            reduce using rule 11 (command -> ESCREVER e_list .)
    ESCREVER        reduce using rule 11 (command -> ESCREVER e_list .)
    REAL            reduce using rule 11 (command -> ESCREVER e_list .)
    INTEIRO         reduce using rule 11 (command -> ESCREVER e_list .)
    CARACTER        reduce using rule 11 (command -> ESCREVER e_list .)
    -               reduce using rule 11 (command -> ESCREVER e_list .)
    (               reduce using rule 11 (command -> ESCREVER e_list .)
    VAR             reduce using rule 11 (command -> ESCREVER e_list .)
    PARA            reduce using rule 11 (command -> ESCREVER e_list .)
    SE              reduce using rule 11 (command -> ESCREVER e_list .)
    FUNCAO          reduce using rule 11 (command -> ESCREVER e_list .)
    TRUE            reduce using rule 11 (command -> ESCREVER e_list .)
    FALSE           reduce using rule 11 (command -> ESCREVER e_list .)
    NOT             reduce using rule 11 (command -> ESCREVER e_list .)
    $end            reduce using rule 11 (command -> ESCREVER e_list .)
    FIM_SE          reduce using rule 11 (command -> ESCREVER e_list .)
    SENAO           reduce using rule 11 (command -> ESCREVER e_list .)
    FIM_FUNCAO      reduce using rule 11 (command -> ESCREVER e_list .)
    FIM             reduce using rule 11 (command -> ESCREVER e_list .)
    ,               shift and go to state 71


state 45

    (22) var_list -> VAR .
    (40) e -> VAR .

  ! reduce/reduce conflict for - resolved using rule 22 (var_list -> VAR .)
  ! reduce/reduce conflict for , resolved using rule 22 (var_list -> VAR .)
  ! reduce/reduce conflict for VARS resolved using rule 22 (var_list -> VAR .)
  ! reduce/reduce conflict for ESCREVER resolved using rule 22 (var_list -> VAR .)
  ! reduce/reduce conflict for REAL resolved using rule 22 (var_list -> VAR .)
  ! reduce/reduce conflict for INTEIRO resolved using rule 22 (var_list -> VAR .)
  ! reduce/reduce conflict for CARACTER resolved using rule 22 (var_list -> VAR .)
  ! reduce/reduce conflict for ( resolved using rule 22 (var_list -> VAR .)
  ! reduce/reduce conflict for VAR resolved using rule 22 (var_list -> VAR .)
  ! reduce/reduce conflict for PARA resolved using rule 22 (var_list -> VAR .)
  ! reduce/reduce conflict for SE resolved using rule 22 (var_list -> VAR .)
  ! reduce/reduce conflict for FUNCAO resolved using rule 22 (var_list -> VAR .)
  ! reduce/reduce conflict for TRUE resolved using rule 22 (var_list -> VAR .)
  ! reduce/reduce conflict for FALSE resolved using rule 22 (var_list -> VAR .)
  ! reduce/reduce conflict for NOT resolved using rule 22 (var_list -> VAR .)
  ! reduce/reduce conflict for $end resolved using rule 22 (var_list -> VAR .)
  ! reduce/reduce conflict for FIM_SE resolved using rule 22 (var_list -> VAR .)
  ! reduce/reduce conflict for SENAO resolved using rule 22 (var_list -> VAR .)
  ! reduce/reduce conflict for FIM_FUNCAO resolved using rule 22 (var_list -> VAR .)
  ! reduce/reduce conflict for FIM resolved using rule 22 (var_list -> VAR .)
    ,               reduce using rule 22 (var_list -> VAR .)
    VARS            reduce using rule 22 (var_list -> VAR .)
    ESCREVER        reduce using rule 22 (var_list -> VAR .)
    REAL            reduce using rule 22 (var_list -> VAR .)
    INTEIRO         reduce using rule 22 (var_list -> VAR .)
    CARACTER        reduce using rule 22 (var_list -> VAR .)
    -               reduce using rule 22 (var_list -> VAR .)
    (               reduce using rule 22 (var_list -> VAR .)
    VAR             reduce using rule 22 (var_list -> VAR .)
    PARA            reduce using rule 22 (var_list -> VAR .)
    SE              reduce using rule 22 (var_list -> VAR .)
    FUNCAO          reduce using rule 22 (var_list -> VAR .)
    TRUE            reduce using rule 22 (var_list -> VAR .)
    FALSE           reduce using rule 22 (var_list -> VAR .)
    NOT             reduce using rule 22 (var_list -> VAR .)
    $end            reduce using rule 22 (var_list -> VAR .)
    FIM_SE          reduce using rule 22 (var_list -> VAR .)
    SENAO           reduce using rule 22 (var_list -> VAR .)
    FIM_FUNCAO      reduce using rule 22 (var_list -> VAR .)
    FIM             reduce using rule 22 (var_list -> VAR .)
    *               reduce using rule 40 (e -> VAR .)
    /               reduce using rule 40 (e -> VAR .)
    +               reduce using rule 40 (e -> VAR .)
    OR              reduce using rule 40 (e -> VAR .)
    AND             reduce using rule 40 (e -> VAR .)
    XOR             reduce using rule 40 (e -> VAR .)
    SMALLER         reduce using rule 40 (e -> VAR .)
    SMALLER_EQUAL   reduce using rule 40 (e -> VAR .)
    BIGGER          reduce using rule 40 (e -> VAR .)
    BIGGER_EQUAL    reduce using rule 40 (e -> VAR .)
    EQUAL           reduce using rule 40 (e -> VAR .)
    NOT_EQUAL       reduce using rule 40 (e -> VAR .)

  ! -               [ reduce using rule 40 (e -> VAR .) ]
  ! ,               [ reduce using rule 40 (e -> VAR .) ]
  ! VARS            [ reduce using rule 40 (e -> VAR .) ]
  ! ESCREVER        [ reduce using rule 40 (e -> VAR .) ]
  ! REAL            [ reduce using rule 40 (e -> VAR .) ]
  ! INTEIRO         [ reduce using rule 40 (e -> VAR .) ]
  ! CARACTER        [ reduce using rule 40 (e -> VAR .) ]
  ! (               [ reduce using rule 40 (e -> VAR .) ]
  ! VAR             [ reduce using rule 40 (e -> VAR .) ]
  ! PARA            [ reduce using rule 40 (e -> VAR .) ]
  ! SE              [ reduce using rule 40 (e -> VAR .) ]
  ! FUNCAO          [ reduce using rule 40 (e -> VAR .) ]
  ! TRUE            [ reduce using rule 40 (e -> VAR .) ]
  ! FALSE           [ reduce using rule 40 (e -> VAR .) ]
  ! NOT             [ reduce using rule 40 (e -> VAR .) ]
  ! $end            [ reduce using rule 40 (e -> VAR .) ]
  ! FIM_SE          [ reduce using rule 40 (e -> VAR .) ]
  ! SENAO           [ reduce using rule 40 (e -> VAR .) ]
  ! FIM_FUNCAO      [ reduce using rule 40 (e -> VAR .) ]
  ! FIM             [ reduce using rule 40 (e -> VAR .) ]


state 46

    (24) e_list -> e .
    (31) e -> e . * e
    (32) e -> e . / e
    (33) e -> e . + e
    (34) e -> e . - e
    (36) e -> e . OR e
    (37) e -> e . AND e
    (38) e -> e . XOR e
    (41) condicao -> e . SMALLER e
    (42) condicao -> e . SMALLER_EQUAL e
    (43) condicao -> e . BIGGER e
    (44) condicao -> e . BIGGER_EQUAL e
    (45) condicao -> e . EQUAL e
    (46) condicao -> e . NOT_EQUAL e

  ! shift/reduce conflict for - resolved as shift
    ,               reduce using rule 24 (e_list -> e .)
    VARS            reduce using rule 24 (e_list -> e .)
    ESCREVER        reduce using rule 24 (e_list -> e .)
    REAL            reduce using rule 24 (e_list -> e .)
    INTEIRO         reduce using rule 24 (e_list -> e .)
    CARACTER        reduce using rule 24 (e_list -> e .)
    (               reduce using rule 24 (e_list -> e .)
    VAR             reduce using rule 24 (e_list -> e .)
    PARA            reduce using rule 24 (e_list -> e .)
    SE              reduce using rule 24 (e_list -> e .)
    FUNCAO          reduce using rule 24 (e_list -> e .)
    TRUE            reduce using rule 24 (e_list -> e .)
    FALSE           reduce using rule 24 (e_list -> e .)
    NOT             reduce using rule 24 (e_list -> e .)
    $end            reduce using rule 24 (e_list -> e .)
    FIM_SE          reduce using rule 24 (e_list -> e .)
    SENAO           reduce using rule 24 (e_list -> e .)
    FIM_FUNCAO      reduce using rule 24 (e_list -> e .)
    FIM             reduce using rule 24 (e_list -> e .)
    )               reduce using rule 24 (e_list -> e .)
    *               shift and go to state 27
    /               shift and go to state 28
    +               shift and go to state 29
    -               shift and go to state 30
    OR              shift and go to state 31
    AND             shift and go to state 32
    XOR             shift and go to state 33
    SMALLER         shift and go to state 34
    SMALLER_EQUAL   shift and go to state 35
    BIGGER          shift and go to state 36
    BIGGER_EQUAL    shift and go to state 37
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39

  ! -               [ reduce using rule 24 (e_list -> e .) ]


state 47

    (30) e -> - e .
    (31) e -> e . * e
    (32) e -> e . / e
    (33) e -> e . + e
    (34) e -> e . - e
    (36) e -> e . OR e
    (37) e -> e . AND e
    (38) e -> e . XOR e
    (41) condicao -> e . SMALLER e
    (42) condicao -> e . SMALLER_EQUAL e
    (43) condicao -> e . BIGGER e
    (44) condicao -> e . BIGGER_EQUAL e
    (45) condicao -> e . EQUAL e
    (46) condicao -> e . NOT_EQUAL e

    ;               reduce using rule 30 (e -> - e .)
    *               reduce using rule 30 (e -> - e .)
    /               reduce using rule 30 (e -> - e .)
    +               reduce using rule 30 (e -> - e .)
    -               reduce using rule 30 (e -> - e .)
    OR              reduce using rule 30 (e -> - e .)
    AND             reduce using rule 30 (e -> - e .)
    XOR             reduce using rule 30 (e -> - e .)
    SMALLER         reduce using rule 30 (e -> - e .)
    SMALLER_EQUAL   reduce using rule 30 (e -> - e .)
    BIGGER          reduce using rule 30 (e -> - e .)
    BIGGER_EQUAL    reduce using rule 30 (e -> - e .)
    EQUAL           reduce using rule 30 (e -> - e .)
    NOT_EQUAL       reduce using rule 30 (e -> - e .)
    ,               reduce using rule 30 (e -> - e .)
    VARS            reduce using rule 30 (e -> - e .)
    ESCREVER        reduce using rule 30 (e -> - e .)
    REAL            reduce using rule 30 (e -> - e .)
    INTEIRO         reduce using rule 30 (e -> - e .)
    CARACTER        reduce using rule 30 (e -> - e .)
    (               reduce using rule 30 (e -> - e .)
    VAR             reduce using rule 30 (e -> - e .)
    PARA            reduce using rule 30 (e -> - e .)
    SE              reduce using rule 30 (e -> - e .)
    FUNCAO          reduce using rule 30 (e -> - e .)
    TRUE            reduce using rule 30 (e -> - e .)
    FALSE           reduce using rule 30 (e -> - e .)
    NOT             reduce using rule 30 (e -> - e .)
    $end            reduce using rule 30 (e -> - e .)
    FIM_SE          reduce using rule 30 (e -> - e .)
    SENAO           reduce using rule 30 (e -> - e .)
    FIM_FUNCAO      reduce using rule 30 (e -> - e .)
    FIM             reduce using rule 30 (e -> - e .)
    )               reduce using rule 30 (e -> - e .)
    ENTAO           reduce using rule 30 (e -> - e .)

  ! *               [ shift and go to state 27 ]
  ! /               [ shift and go to state 28 ]
  ! +               [ shift and go to state 29 ]
  ! -               [ shift and go to state 30 ]
  ! OR              [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! XOR             [ shift and go to state 33 ]
  ! SMALLER         [ shift and go to state 34 ]
  ! SMALLER_EQUAL   [ shift and go to state 35 ]
  ! BIGGER          [ shift and go to state 36 ]
  ! BIGGER_EQUAL    [ shift and go to state 37 ]
  ! EQUAL           [ shift and go to state 38 ]
  ! NOT_EQUAL       [ shift and go to state 39 ]


state 48

    (40) e -> VAR .

    *               reduce using rule 40 (e -> VAR .)
    /               reduce using rule 40 (e -> VAR .)
    +               reduce using rule 40 (e -> VAR .)
    -               reduce using rule 40 (e -> VAR .)
    OR              reduce using rule 40 (e -> VAR .)
    AND             reduce using rule 40 (e -> VAR .)
    XOR             reduce using rule 40 (e -> VAR .)
    SMALLER         reduce using rule 40 (e -> VAR .)
    SMALLER_EQUAL   reduce using rule 40 (e -> VAR .)
    BIGGER          reduce using rule 40 (e -> VAR .)
    BIGGER_EQUAL    reduce using rule 40 (e -> VAR .)
    EQUAL           reduce using rule 40 (e -> VAR .)
    NOT_EQUAL       reduce using rule 40 (e -> VAR .)
    ;               reduce using rule 40 (e -> VAR .)
    ,               reduce using rule 40 (e -> VAR .)
    VARS            reduce using rule 40 (e -> VAR .)
    ESCREVER        reduce using rule 40 (e -> VAR .)
    REAL            reduce using rule 40 (e -> VAR .)
    INTEIRO         reduce using rule 40 (e -> VAR .)
    CARACTER        reduce using rule 40 (e -> VAR .)
    (               reduce using rule 40 (e -> VAR .)
    VAR             reduce using rule 40 (e -> VAR .)
    PARA            reduce using rule 40 (e -> VAR .)
    SE              reduce using rule 40 (e -> VAR .)
    FUNCAO          reduce using rule 40 (e -> VAR .)
    TRUE            reduce using rule 40 (e -> VAR .)
    FALSE           reduce using rule 40 (e -> VAR .)
    NOT             reduce using rule 40 (e -> VAR .)
    $end            reduce using rule 40 (e -> VAR .)
    FIM_SE          reduce using rule 40 (e -> VAR .)
    SENAO           reduce using rule 40 (e -> VAR .)
    FIM_FUNCAO      reduce using rule 40 (e -> VAR .)
    FIM             reduce using rule 40 (e -> VAR .)
    )               reduce using rule 40 (e -> VAR .)
    ENTAO           reduce using rule 40 (e -> VAR .)


state 49

    (39) e -> ( e . )
    (31) e -> e . * e
    (32) e -> e . / e
    (33) e -> e . + e
    (34) e -> e . - e
    (36) e -> e . OR e
    (37) e -> e . AND e
    (38) e -> e . XOR e
    (41) condicao -> e . SMALLER e
    (42) condicao -> e . SMALLER_EQUAL e
    (43) condicao -> e . BIGGER e
    (44) condicao -> e . BIGGER_EQUAL e
    (45) condicao -> e . EQUAL e
    (46) condicao -> e . NOT_EQUAL e

    )               shift and go to state 72
    *               shift and go to state 27
    /               shift and go to state 28
    +               shift and go to state 29
    -               shift and go to state 30
    OR              shift and go to state 31
    AND             shift and go to state 32
    XOR             shift and go to state 33
    SMALLER         shift and go to state 34
    SMALLER_EQUAL   shift and go to state 35
    BIGGER          shift and go to state 36
    BIGGER_EQUAL    shift and go to state 37
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39


state 50

    (12) ciclo_for -> PARA VARS . EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM

    EM              shift and go to state 73


state 51

    (13) if -> SE e . ENTAO com_list FIM_SE
    (14) if -> SE e . ENTAO com_list SENAO com_list FIM_SE
    (31) e -> e . * e
    (32) e -> e . / e
    (33) e -> e . + e
    (34) e -> e . - e
    (36) e -> e . OR e
    (37) e -> e . AND e
    (38) e -> e . XOR e
    (41) condicao -> e . SMALLER e
    (42) condicao -> e . SMALLER_EQUAL e
    (43) condicao -> e . BIGGER e
    (44) condicao -> e . BIGGER_EQUAL e
    (45) condicao -> e . EQUAL e
    (46) condicao -> e . NOT_EQUAL e

    ENTAO           shift and go to state 74
    *               shift and go to state 27
    /               shift and go to state 28
    +               shift and go to state 29
    -               shift and go to state 30
    OR              shift and go to state 31
    AND             shift and go to state 32
    XOR             shift and go to state 33
    SMALLER         shift and go to state 34
    SMALLER_EQUAL   shift and go to state 35
    BIGGER          shift and go to state 36
    BIGGER_EQUAL    shift and go to state 37
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39


state 52

    (15) func -> FUNCAO VAR . ( var_fun_list ) com_list FIM_FUNCAO
    (16) func -> FUNCAO VAR . ( ) com_list FIM_FUNCAO

    (               shift and go to state 75


state 53

    (53) logico -> NOT logico .

    ;               reduce using rule 53 (logico -> NOT logico .)
    *               reduce using rule 53 (logico -> NOT logico .)
    /               reduce using rule 53 (logico -> NOT logico .)
    +               reduce using rule 53 (logico -> NOT logico .)
    -               reduce using rule 53 (logico -> NOT logico .)
    OR              reduce using rule 53 (logico -> NOT logico .)
    AND             reduce using rule 53 (logico -> NOT logico .)
    XOR             reduce using rule 53 (logico -> NOT logico .)
    SMALLER         reduce using rule 53 (logico -> NOT logico .)
    SMALLER_EQUAL   reduce using rule 53 (logico -> NOT logico .)
    BIGGER          reduce using rule 53 (logico -> NOT logico .)
    BIGGER_EQUAL    reduce using rule 53 (logico -> NOT logico .)
    EQUAL           reduce using rule 53 (logico -> NOT logico .)
    NOT_EQUAL       reduce using rule 53 (logico -> NOT logico .)
    ,               reduce using rule 53 (logico -> NOT logico .)
    VARS            reduce using rule 53 (logico -> NOT logico .)
    ESCREVER        reduce using rule 53 (logico -> NOT logico .)
    REAL            reduce using rule 53 (logico -> NOT logico .)
    INTEIRO         reduce using rule 53 (logico -> NOT logico .)
    CARACTER        reduce using rule 53 (logico -> NOT logico .)
    (               reduce using rule 53 (logico -> NOT logico .)
    VAR             reduce using rule 53 (logico -> NOT logico .)
    PARA            reduce using rule 53 (logico -> NOT logico .)
    SE              reduce using rule 53 (logico -> NOT logico .)
    FUNCAO          reduce using rule 53 (logico -> NOT logico .)
    TRUE            reduce using rule 53 (logico -> NOT logico .)
    FALSE           reduce using rule 53 (logico -> NOT logico .)
    NOT             reduce using rule 53 (logico -> NOT logico .)
    $end            reduce using rule 53 (logico -> NOT logico .)
    FIM_SE          reduce using rule 53 (logico -> NOT logico .)
    SENAO           reduce using rule 53 (logico -> NOT logico .)
    FIM_FUNCAO      reduce using rule 53 (logico -> NOT logico .)
    FIM             reduce using rule 53 (logico -> NOT logico .)
    )               reduce using rule 53 (logico -> NOT logico .)
    ENTAO           reduce using rule 53 (logico -> NOT logico .)


state 54

    (31) e -> e * e .
    (31) e -> e . * e
    (32) e -> e . / e
    (33) e -> e . + e
    (34) e -> e . - e
    (36) e -> e . OR e
    (37) e -> e . AND e
    (38) e -> e . XOR e
    (41) condicao -> e . SMALLER e
    (42) condicao -> e . SMALLER_EQUAL e
    (43) condicao -> e . BIGGER e
    (44) condicao -> e . BIGGER_EQUAL e
    (45) condicao -> e . EQUAL e
    (46) condicao -> e . NOT_EQUAL e

    ;               reduce using rule 31 (e -> e * e .)
    *               reduce using rule 31 (e -> e * e .)
    /               reduce using rule 31 (e -> e * e .)
    +               reduce using rule 31 (e -> e * e .)
    -               reduce using rule 31 (e -> e * e .)
    OR              reduce using rule 31 (e -> e * e .)
    AND             reduce using rule 31 (e -> e * e .)
    XOR             reduce using rule 31 (e -> e * e .)
    SMALLER         reduce using rule 31 (e -> e * e .)
    SMALLER_EQUAL   reduce using rule 31 (e -> e * e .)
    BIGGER          reduce using rule 31 (e -> e * e .)
    BIGGER_EQUAL    reduce using rule 31 (e -> e * e .)
    EQUAL           reduce using rule 31 (e -> e * e .)
    NOT_EQUAL       reduce using rule 31 (e -> e * e .)
    ,               reduce using rule 31 (e -> e * e .)
    VARS            reduce using rule 31 (e -> e * e .)
    ESCREVER        reduce using rule 31 (e -> e * e .)
    REAL            reduce using rule 31 (e -> e * e .)
    INTEIRO         reduce using rule 31 (e -> e * e .)
    CARACTER        reduce using rule 31 (e -> e * e .)
    (               reduce using rule 31 (e -> e * e .)
    VAR             reduce using rule 31 (e -> e * e .)
    PARA            reduce using rule 31 (e -> e * e .)
    SE              reduce using rule 31 (e -> e * e .)
    FUNCAO          reduce using rule 31 (e -> e * e .)
    TRUE            reduce using rule 31 (e -> e * e .)
    FALSE           reduce using rule 31 (e -> e * e .)
    NOT             reduce using rule 31 (e -> e * e .)
    $end            reduce using rule 31 (e -> e * e .)
    FIM_SE          reduce using rule 31 (e -> e * e .)
    SENAO           reduce using rule 31 (e -> e * e .)
    FIM_FUNCAO      reduce using rule 31 (e -> e * e .)
    FIM             reduce using rule 31 (e -> e * e .)
    )               reduce using rule 31 (e -> e * e .)
    ENTAO           reduce using rule 31 (e -> e * e .)

  ! *               [ shift and go to state 27 ]
  ! /               [ shift and go to state 28 ]
  ! +               [ shift and go to state 29 ]
  ! -               [ shift and go to state 30 ]
  ! OR              [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! XOR             [ shift and go to state 33 ]
  ! SMALLER         [ shift and go to state 34 ]
  ! SMALLER_EQUAL   [ shift and go to state 35 ]
  ! BIGGER          [ shift and go to state 36 ]
  ! BIGGER_EQUAL    [ shift and go to state 37 ]
  ! EQUAL           [ shift and go to state 38 ]
  ! NOT_EQUAL       [ shift and go to state 39 ]


state 55

    (32) e -> e / e .
    (31) e -> e . * e
    (32) e -> e . / e
    (33) e -> e . + e
    (34) e -> e . - e
    (36) e -> e . OR e
    (37) e -> e . AND e
    (38) e -> e . XOR e
    (41) condicao -> e . SMALLER e
    (42) condicao -> e . SMALLER_EQUAL e
    (43) condicao -> e . BIGGER e
    (44) condicao -> e . BIGGER_EQUAL e
    (45) condicao -> e . EQUAL e
    (46) condicao -> e . NOT_EQUAL e

    ;               reduce using rule 32 (e -> e / e .)
    *               reduce using rule 32 (e -> e / e .)
    /               reduce using rule 32 (e -> e / e .)
    +               reduce using rule 32 (e -> e / e .)
    -               reduce using rule 32 (e -> e / e .)
    OR              reduce using rule 32 (e -> e / e .)
    AND             reduce using rule 32 (e -> e / e .)
    XOR             reduce using rule 32 (e -> e / e .)
    SMALLER         reduce using rule 32 (e -> e / e .)
    SMALLER_EQUAL   reduce using rule 32 (e -> e / e .)
    BIGGER          reduce using rule 32 (e -> e / e .)
    BIGGER_EQUAL    reduce using rule 32 (e -> e / e .)
    EQUAL           reduce using rule 32 (e -> e / e .)
    NOT_EQUAL       reduce using rule 32 (e -> e / e .)
    ,               reduce using rule 32 (e -> e / e .)
    VARS            reduce using rule 32 (e -> e / e .)
    ESCREVER        reduce using rule 32 (e -> e / e .)
    REAL            reduce using rule 32 (e -> e / e .)
    INTEIRO         reduce using rule 32 (e -> e / e .)
    CARACTER        reduce using rule 32 (e -> e / e .)
    (               reduce using rule 32 (e -> e / e .)
    VAR             reduce using rule 32 (e -> e / e .)
    PARA            reduce using rule 32 (e -> e / e .)
    SE              reduce using rule 32 (e -> e / e .)
    FUNCAO          reduce using rule 32 (e -> e / e .)
    TRUE            reduce using rule 32 (e -> e / e .)
    FALSE           reduce using rule 32 (e -> e / e .)
    NOT             reduce using rule 32 (e -> e / e .)
    $end            reduce using rule 32 (e -> e / e .)
    FIM_SE          reduce using rule 32 (e -> e / e .)
    SENAO           reduce using rule 32 (e -> e / e .)
    FIM_FUNCAO      reduce using rule 32 (e -> e / e .)
    FIM             reduce using rule 32 (e -> e / e .)
    )               reduce using rule 32 (e -> e / e .)
    ENTAO           reduce using rule 32 (e -> e / e .)

  ! *               [ shift and go to state 27 ]
  ! /               [ shift and go to state 28 ]
  ! +               [ shift and go to state 29 ]
  ! -               [ shift and go to state 30 ]
  ! OR              [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! XOR             [ shift and go to state 33 ]
  ! SMALLER         [ shift and go to state 34 ]
  ! SMALLER_EQUAL   [ shift and go to state 35 ]
  ! BIGGER          [ shift and go to state 36 ]
  ! BIGGER_EQUAL    [ shift and go to state 37 ]
  ! EQUAL           [ shift and go to state 38 ]
  ! NOT_EQUAL       [ shift and go to state 39 ]


state 56

    (33) e -> e + e .
    (31) e -> e . * e
    (32) e -> e . / e
    (33) e -> e . + e
    (34) e -> e . - e
    (36) e -> e . OR e
    (37) e -> e . AND e
    (38) e -> e . XOR e
    (41) condicao -> e . SMALLER e
    (42) condicao -> e . SMALLER_EQUAL e
    (43) condicao -> e . BIGGER e
    (44) condicao -> e . BIGGER_EQUAL e
    (45) condicao -> e . EQUAL e
    (46) condicao -> e . NOT_EQUAL e

    ;               reduce using rule 33 (e -> e + e .)
    +               reduce using rule 33 (e -> e + e .)
    -               reduce using rule 33 (e -> e + e .)
    OR              reduce using rule 33 (e -> e + e .)
    AND             reduce using rule 33 (e -> e + e .)
    XOR             reduce using rule 33 (e -> e + e .)
    SMALLER         reduce using rule 33 (e -> e + e .)
    SMALLER_EQUAL   reduce using rule 33 (e -> e + e .)
    BIGGER          reduce using rule 33 (e -> e + e .)
    BIGGER_EQUAL    reduce using rule 33 (e -> e + e .)
    EQUAL           reduce using rule 33 (e -> e + e .)
    NOT_EQUAL       reduce using rule 33 (e -> e + e .)
    ,               reduce using rule 33 (e -> e + e .)
    VARS            reduce using rule 33 (e -> e + e .)
    ESCREVER        reduce using rule 33 (e -> e + e .)
    REAL            reduce using rule 33 (e -> e + e .)
    INTEIRO         reduce using rule 33 (e -> e + e .)
    CARACTER        reduce using rule 33 (e -> e + e .)
    (               reduce using rule 33 (e -> e + e .)
    VAR             reduce using rule 33 (e -> e + e .)
    PARA            reduce using rule 33 (e -> e + e .)
    SE              reduce using rule 33 (e -> e + e .)
    FUNCAO          reduce using rule 33 (e -> e + e .)
    TRUE            reduce using rule 33 (e -> e + e .)
    FALSE           reduce using rule 33 (e -> e + e .)
    NOT             reduce using rule 33 (e -> e + e .)
    $end            reduce using rule 33 (e -> e + e .)
    FIM_SE          reduce using rule 33 (e -> e + e .)
    SENAO           reduce using rule 33 (e -> e + e .)
    FIM_FUNCAO      reduce using rule 33 (e -> e + e .)
    FIM             reduce using rule 33 (e -> e + e .)
    )               reduce using rule 33 (e -> e + e .)
    ENTAO           reduce using rule 33 (e -> e + e .)
    *               shift and go to state 27
    /               shift and go to state 28

  ! *               [ reduce using rule 33 (e -> e + e .) ]
  ! /               [ reduce using rule 33 (e -> e + e .) ]
  ! +               [ shift and go to state 29 ]
  ! -               [ shift and go to state 30 ]
  ! OR              [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! XOR             [ shift and go to state 33 ]
  ! SMALLER         [ shift and go to state 34 ]
  ! SMALLER_EQUAL   [ shift and go to state 35 ]
  ! BIGGER          [ shift and go to state 36 ]
  ! BIGGER_EQUAL    [ shift and go to state 37 ]
  ! EQUAL           [ shift and go to state 38 ]
  ! NOT_EQUAL       [ shift and go to state 39 ]


state 57

    (34) e -> e - e .
    (31) e -> e . * e
    (32) e -> e . / e
    (33) e -> e . + e
    (34) e -> e . - e
    (36) e -> e . OR e
    (37) e -> e . AND e
    (38) e -> e . XOR e
    (41) condicao -> e . SMALLER e
    (42) condicao -> e . SMALLER_EQUAL e
    (43) condicao -> e . BIGGER e
    (44) condicao -> e . BIGGER_EQUAL e
    (45) condicao -> e . EQUAL e
    (46) condicao -> e . NOT_EQUAL e

    ;               reduce using rule 34 (e -> e - e .)
    +               reduce using rule 34 (e -> e - e .)
    -               reduce using rule 34 (e -> e - e .)
    OR              reduce using rule 34 (e -> e - e .)
    AND             reduce using rule 34 (e -> e - e .)
    XOR             reduce using rule 34 (e -> e - e .)
    SMALLER         reduce using rule 34 (e -> e - e .)
    SMALLER_EQUAL   reduce using rule 34 (e -> e - e .)
    BIGGER          reduce using rule 34 (e -> e - e .)
    BIGGER_EQUAL    reduce using rule 34 (e -> e - e .)
    EQUAL           reduce using rule 34 (e -> e - e .)
    NOT_EQUAL       reduce using rule 34 (e -> e - e .)
    ,               reduce using rule 34 (e -> e - e .)
    VARS            reduce using rule 34 (e -> e - e .)
    ESCREVER        reduce using rule 34 (e -> e - e .)
    REAL            reduce using rule 34 (e -> e - e .)
    INTEIRO         reduce using rule 34 (e -> e - e .)
    CARACTER        reduce using rule 34 (e -> e - e .)
    (               reduce using rule 34 (e -> e - e .)
    VAR             reduce using rule 34 (e -> e - e .)
    PARA            reduce using rule 34 (e -> e - e .)
    SE              reduce using rule 34 (e -> e - e .)
    FUNCAO          reduce using rule 34 (e -> e - e .)
    TRUE            reduce using rule 34 (e -> e - e .)
    FALSE           reduce using rule 34 (e -> e - e .)
    NOT             reduce using rule 34 (e -> e - e .)
    $end            reduce using rule 34 (e -> e - e .)
    FIM_SE          reduce using rule 34 (e -> e - e .)
    SENAO           reduce using rule 34 (e -> e - e .)
    FIM_FUNCAO      reduce using rule 34 (e -> e - e .)
    FIM             reduce using rule 34 (e -> e - e .)
    )               reduce using rule 34 (e -> e - e .)
    ENTAO           reduce using rule 34 (e -> e - e .)
    *               shift and go to state 27
    /               shift and go to state 28

  ! *               [ reduce using rule 34 (e -> e - e .) ]
  ! /               [ reduce using rule 34 (e -> e - e .) ]
  ! +               [ shift and go to state 29 ]
  ! -               [ shift and go to state 30 ]
  ! OR              [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! XOR             [ shift and go to state 33 ]
  ! SMALLER         [ shift and go to state 34 ]
  ! SMALLER_EQUAL   [ shift and go to state 35 ]
  ! BIGGER          [ shift and go to state 36 ]
  ! BIGGER_EQUAL    [ shift and go to state 37 ]
  ! EQUAL           [ shift and go to state 38 ]
  ! NOT_EQUAL       [ shift and go to state 39 ]


state 58

    (36) e -> e OR e .
    (31) e -> e . * e
    (32) e -> e . / e
    (33) e -> e . + e
    (34) e -> e . - e
    (36) e -> e . OR e
    (37) e -> e . AND e
    (38) e -> e . XOR e
    (41) condicao -> e . SMALLER e
    (42) condicao -> e . SMALLER_EQUAL e
    (43) condicao -> e . BIGGER e
    (44) condicao -> e . BIGGER_EQUAL e
    (45) condicao -> e . EQUAL e
    (46) condicao -> e . NOT_EQUAL e

    ;               reduce using rule 36 (e -> e OR e .)
    OR              reduce using rule 36 (e -> e OR e .)
    XOR             reduce using rule 36 (e -> e OR e .)
    ,               reduce using rule 36 (e -> e OR e .)
    VARS            reduce using rule 36 (e -> e OR e .)
    ESCREVER        reduce using rule 36 (e -> e OR e .)
    REAL            reduce using rule 36 (e -> e OR e .)
    INTEIRO         reduce using rule 36 (e -> e OR e .)
    CARACTER        reduce using rule 36 (e -> e OR e .)
    (               reduce using rule 36 (e -> e OR e .)
    VAR             reduce using rule 36 (e -> e OR e .)
    PARA            reduce using rule 36 (e -> e OR e .)
    SE              reduce using rule 36 (e -> e OR e .)
    FUNCAO          reduce using rule 36 (e -> e OR e .)
    TRUE            reduce using rule 36 (e -> e OR e .)
    FALSE           reduce using rule 36 (e -> e OR e .)
    NOT             reduce using rule 36 (e -> e OR e .)
    $end            reduce using rule 36 (e -> e OR e .)
    FIM_SE          reduce using rule 36 (e -> e OR e .)
    SENAO           reduce using rule 36 (e -> e OR e .)
    FIM_FUNCAO      reduce using rule 36 (e -> e OR e .)
    FIM             reduce using rule 36 (e -> e OR e .)
    )               reduce using rule 36 (e -> e OR e .)
    ENTAO           reduce using rule 36 (e -> e OR e .)
    *               shift and go to state 27
    /               shift and go to state 28
    +               shift and go to state 29
    -               shift and go to state 30
    AND             shift and go to state 32
    SMALLER         shift and go to state 34
    SMALLER_EQUAL   shift and go to state 35
    BIGGER          shift and go to state 36
    BIGGER_EQUAL    shift and go to state 37
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39

  ! *               [ reduce using rule 36 (e -> e OR e .) ]
  ! /               [ reduce using rule 36 (e -> e OR e .) ]
  ! +               [ reduce using rule 36 (e -> e OR e .) ]
  ! -               [ reduce using rule 36 (e -> e OR e .) ]
  ! AND             [ reduce using rule 36 (e -> e OR e .) ]
  ! SMALLER         [ reduce using rule 36 (e -> e OR e .) ]
  ! SMALLER_EQUAL   [ reduce using rule 36 (e -> e OR e .) ]
  ! BIGGER          [ reduce using rule 36 (e -> e OR e .) ]
  ! BIGGER_EQUAL    [ reduce using rule 36 (e -> e OR e .) ]
  ! EQUAL           [ reduce using rule 36 (e -> e OR e .) ]
  ! NOT_EQUAL       [ reduce using rule 36 (e -> e OR e .) ]
  ! OR              [ shift and go to state 31 ]
  ! XOR             [ shift and go to state 33 ]


state 59

    (37) e -> e AND e .
    (31) e -> e . * e
    (32) e -> e . / e
    (33) e -> e . + e
    (34) e -> e . - e
    (36) e -> e . OR e
    (37) e -> e . AND e
    (38) e -> e . XOR e
    (41) condicao -> e . SMALLER e
    (42) condicao -> e . SMALLER_EQUAL e
    (43) condicao -> e . BIGGER e
    (44) condicao -> e . BIGGER_EQUAL e
    (45) condicao -> e . EQUAL e
    (46) condicao -> e . NOT_EQUAL e

    ;               reduce using rule 37 (e -> e AND e .)
    OR              reduce using rule 37 (e -> e AND e .)
    AND             reduce using rule 37 (e -> e AND e .)
    XOR             reduce using rule 37 (e -> e AND e .)
    ,               reduce using rule 37 (e -> e AND e .)
    VARS            reduce using rule 37 (e -> e AND e .)
    ESCREVER        reduce using rule 37 (e -> e AND e .)
    REAL            reduce using rule 37 (e -> e AND e .)
    INTEIRO         reduce using rule 37 (e -> e AND e .)
    CARACTER        reduce using rule 37 (e -> e AND e .)
    (               reduce using rule 37 (e -> e AND e .)
    VAR             reduce using rule 37 (e -> e AND e .)
    PARA            reduce using rule 37 (e -> e AND e .)
    SE              reduce using rule 37 (e -> e AND e .)
    FUNCAO          reduce using rule 37 (e -> e AND e .)
    TRUE            reduce using rule 37 (e -> e AND e .)
    FALSE           reduce using rule 37 (e -> e AND e .)
    NOT             reduce using rule 37 (e -> e AND e .)
    $end            reduce using rule 37 (e -> e AND e .)
    FIM_SE          reduce using rule 37 (e -> e AND e .)
    SENAO           reduce using rule 37 (e -> e AND e .)
    FIM_FUNCAO      reduce using rule 37 (e -> e AND e .)
    FIM             reduce using rule 37 (e -> e AND e .)
    )               reduce using rule 37 (e -> e AND e .)
    ENTAO           reduce using rule 37 (e -> e AND e .)
    *               shift and go to state 27
    /               shift and go to state 28
    +               shift and go to state 29
    -               shift and go to state 30
    SMALLER         shift and go to state 34
    SMALLER_EQUAL   shift and go to state 35
    BIGGER          shift and go to state 36
    BIGGER_EQUAL    shift and go to state 37
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39

  ! *               [ reduce using rule 37 (e -> e AND e .) ]
  ! /               [ reduce using rule 37 (e -> e AND e .) ]
  ! +               [ reduce using rule 37 (e -> e AND e .) ]
  ! -               [ reduce using rule 37 (e -> e AND e .) ]
  ! SMALLER         [ reduce using rule 37 (e -> e AND e .) ]
  ! SMALLER_EQUAL   [ reduce using rule 37 (e -> e AND e .) ]
  ! BIGGER          [ reduce using rule 37 (e -> e AND e .) ]
  ! BIGGER_EQUAL    [ reduce using rule 37 (e -> e AND e .) ]
  ! EQUAL           [ reduce using rule 37 (e -> e AND e .) ]
  ! NOT_EQUAL       [ reduce using rule 37 (e -> e AND e .) ]
  ! OR              [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! XOR             [ shift and go to state 33 ]


state 60

    (38) e -> e XOR e .
    (31) e -> e . * e
    (32) e -> e . / e
    (33) e -> e . + e
    (34) e -> e . - e
    (36) e -> e . OR e
    (37) e -> e . AND e
    (38) e -> e . XOR e
    (41) condicao -> e . SMALLER e
    (42) condicao -> e . SMALLER_EQUAL e
    (43) condicao -> e . BIGGER e
    (44) condicao -> e . BIGGER_EQUAL e
    (45) condicao -> e . EQUAL e
    (46) condicao -> e . NOT_EQUAL e

    ;               reduce using rule 38 (e -> e XOR e .)
    OR              reduce using rule 38 (e -> e XOR e .)
    XOR             reduce using rule 38 (e -> e XOR e .)
    ,               reduce using rule 38 (e -> e XOR e .)
    VARS            reduce using rule 38 (e -> e XOR e .)
    ESCREVER        reduce using rule 38 (e -> e XOR e .)
    REAL            reduce using rule 38 (e -> e XOR e .)
    INTEIRO         reduce using rule 38 (e -> e XOR e .)
    CARACTER        reduce using rule 38 (e -> e XOR e .)
    (               reduce using rule 38 (e -> e XOR e .)
    VAR             reduce using rule 38 (e -> e XOR e .)
    PARA            reduce using rule 38 (e -> e XOR e .)
    SE              reduce using rule 38 (e -> e XOR e .)
    FUNCAO          reduce using rule 38 (e -> e XOR e .)
    TRUE            reduce using rule 38 (e -> e XOR e .)
    FALSE           reduce using rule 38 (e -> e XOR e .)
    NOT             reduce using rule 38 (e -> e XOR e .)
    $end            reduce using rule 38 (e -> e XOR e .)
    FIM_SE          reduce using rule 38 (e -> e XOR e .)
    SENAO           reduce using rule 38 (e -> e XOR e .)
    FIM_FUNCAO      reduce using rule 38 (e -> e XOR e .)
    FIM             reduce using rule 38 (e -> e XOR e .)
    )               reduce using rule 38 (e -> e XOR e .)
    ENTAO           reduce using rule 38 (e -> e XOR e .)
    *               shift and go to state 27
    /               shift and go to state 28
    +               shift and go to state 29
    -               shift and go to state 30
    AND             shift and go to state 32
    SMALLER         shift and go to state 34
    SMALLER_EQUAL   shift and go to state 35
    BIGGER          shift and go to state 36
    BIGGER_EQUAL    shift and go to state 37
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39

  ! *               [ reduce using rule 38 (e -> e XOR e .) ]
  ! /               [ reduce using rule 38 (e -> e XOR e .) ]
  ! +               [ reduce using rule 38 (e -> e XOR e .) ]
  ! -               [ reduce using rule 38 (e -> e XOR e .) ]
  ! AND             [ reduce using rule 38 (e -> e XOR e .) ]
  ! SMALLER         [ reduce using rule 38 (e -> e XOR e .) ]
  ! SMALLER_EQUAL   [ reduce using rule 38 (e -> e XOR e .) ]
  ! BIGGER          [ reduce using rule 38 (e -> e XOR e .) ]
  ! BIGGER_EQUAL    [ reduce using rule 38 (e -> e XOR e .) ]
  ! EQUAL           [ reduce using rule 38 (e -> e XOR e .) ]
  ! NOT_EQUAL       [ reduce using rule 38 (e -> e XOR e .) ]
  ! OR              [ shift and go to state 31 ]
  ! XOR             [ shift and go to state 33 ]


state 61

    (41) condicao -> e SMALLER e .
    (31) e -> e . * e
    (32) e -> e . / e
    (33) e -> e . + e
    (34) e -> e . - e
    (36) e -> e . OR e
    (37) e -> e . AND e
    (38) e -> e . XOR e
    (41) condicao -> e . SMALLER e
    (42) condicao -> e . SMALLER_EQUAL e
    (43) condicao -> e . BIGGER e
    (44) condicao -> e . BIGGER_EQUAL e
    (45) condicao -> e . EQUAL e
    (46) condicao -> e . NOT_EQUAL e

    ;               reduce using rule 41 (condicao -> e SMALLER e .)
    OR              reduce using rule 41 (condicao -> e SMALLER e .)
    AND             reduce using rule 41 (condicao -> e SMALLER e .)
    XOR             reduce using rule 41 (condicao -> e SMALLER e .)
    SMALLER         reduce using rule 41 (condicao -> e SMALLER e .)
    BIGGER          reduce using rule 41 (condicao -> e SMALLER e .)
    BIGGER_EQUAL    reduce using rule 41 (condicao -> e SMALLER e .)
    ,               reduce using rule 41 (condicao -> e SMALLER e .)
    VARS            reduce using rule 41 (condicao -> e SMALLER e .)
    ESCREVER        reduce using rule 41 (condicao -> e SMALLER e .)
    REAL            reduce using rule 41 (condicao -> e SMALLER e .)
    INTEIRO         reduce using rule 41 (condicao -> e SMALLER e .)
    CARACTER        reduce using rule 41 (condicao -> e SMALLER e .)
    (               reduce using rule 41 (condicao -> e SMALLER e .)
    VAR             reduce using rule 41 (condicao -> e SMALLER e .)
    PARA            reduce using rule 41 (condicao -> e SMALLER e .)
    SE              reduce using rule 41 (condicao -> e SMALLER e .)
    FUNCAO          reduce using rule 41 (condicao -> e SMALLER e .)
    TRUE            reduce using rule 41 (condicao -> e SMALLER e .)
    FALSE           reduce using rule 41 (condicao -> e SMALLER e .)
    NOT             reduce using rule 41 (condicao -> e SMALLER e .)
    $end            reduce using rule 41 (condicao -> e SMALLER e .)
    FIM_SE          reduce using rule 41 (condicao -> e SMALLER e .)
    SENAO           reduce using rule 41 (condicao -> e SMALLER e .)
    FIM_FUNCAO      reduce using rule 41 (condicao -> e SMALLER e .)
    FIM             reduce using rule 41 (condicao -> e SMALLER e .)
    )               reduce using rule 41 (condicao -> e SMALLER e .)
    ENTAO           reduce using rule 41 (condicao -> e SMALLER e .)
    *               shift and go to state 27
    /               shift and go to state 28
    +               shift and go to state 29
    -               shift and go to state 30
    SMALLER_EQUAL   shift and go to state 35
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39

  ! *               [ reduce using rule 41 (condicao -> e SMALLER e .) ]
  ! /               [ reduce using rule 41 (condicao -> e SMALLER e .) ]
  ! +               [ reduce using rule 41 (condicao -> e SMALLER e .) ]
  ! -               [ reduce using rule 41 (condicao -> e SMALLER e .) ]
  ! SMALLER_EQUAL   [ reduce using rule 41 (condicao -> e SMALLER e .) ]
  ! EQUAL           [ reduce using rule 41 (condicao -> e SMALLER e .) ]
  ! NOT_EQUAL       [ reduce using rule 41 (condicao -> e SMALLER e .) ]
  ! OR              [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! XOR             [ shift and go to state 33 ]
  ! SMALLER         [ shift and go to state 34 ]
  ! BIGGER          [ shift and go to state 36 ]
  ! BIGGER_EQUAL    [ shift and go to state 37 ]


state 62

    (42) condicao -> e SMALLER_EQUAL e .
    (31) e -> e . * e
    (32) e -> e . / e
    (33) e -> e . + e
    (34) e -> e . - e
    (36) e -> e . OR e
    (37) e -> e . AND e
    (38) e -> e . XOR e
    (41) condicao -> e . SMALLER e
    (42) condicao -> e . SMALLER_EQUAL e
    (43) condicao -> e . BIGGER e
    (44) condicao -> e . BIGGER_EQUAL e
    (45) condicao -> e . EQUAL e
    (46) condicao -> e . NOT_EQUAL e

    ;               reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    OR              reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    AND             reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    XOR             reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    SMALLER         reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    SMALLER_EQUAL   reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    BIGGER          reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    BIGGER_EQUAL    reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    ,               reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    VARS            reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    ESCREVER        reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    REAL            reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    INTEIRO         reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    CARACTER        reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    (               reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    VAR             reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    PARA            reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    SE              reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    FUNCAO          reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    TRUE            reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    FALSE           reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    NOT             reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    $end            reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    FIM_SE          reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    SENAO           reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    FIM_FUNCAO      reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    FIM             reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    )               reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    ENTAO           reduce using rule 42 (condicao -> e SMALLER_EQUAL e .)
    *               shift and go to state 27
    /               shift and go to state 28
    +               shift and go to state 29
    -               shift and go to state 30
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39

  ! *               [ reduce using rule 42 (condicao -> e SMALLER_EQUAL e .) ]
  ! /               [ reduce using rule 42 (condicao -> e SMALLER_EQUAL e .) ]
  ! +               [ reduce using rule 42 (condicao -> e SMALLER_EQUAL e .) ]
  ! -               [ reduce using rule 42 (condicao -> e SMALLER_EQUAL e .) ]
  ! EQUAL           [ reduce using rule 42 (condicao -> e SMALLER_EQUAL e .) ]
  ! NOT_EQUAL       [ reduce using rule 42 (condicao -> e SMALLER_EQUAL e .) ]
  ! OR              [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! XOR             [ shift and go to state 33 ]
  ! SMALLER         [ shift and go to state 34 ]
  ! SMALLER_EQUAL   [ shift and go to state 35 ]
  ! BIGGER          [ shift and go to state 36 ]
  ! BIGGER_EQUAL    [ shift and go to state 37 ]


state 63

    (43) condicao -> e BIGGER e .
    (31) e -> e . * e
    (32) e -> e . / e
    (33) e -> e . + e
    (34) e -> e . - e
    (36) e -> e . OR e
    (37) e -> e . AND e
    (38) e -> e . XOR e
    (41) condicao -> e . SMALLER e
    (42) condicao -> e . SMALLER_EQUAL e
    (43) condicao -> e . BIGGER e
    (44) condicao -> e . BIGGER_EQUAL e
    (45) condicao -> e . EQUAL e
    (46) condicao -> e . NOT_EQUAL e

    ;               reduce using rule 43 (condicao -> e BIGGER e .)
    OR              reduce using rule 43 (condicao -> e BIGGER e .)
    AND             reduce using rule 43 (condicao -> e BIGGER e .)
    XOR             reduce using rule 43 (condicao -> e BIGGER e .)
    BIGGER          reduce using rule 43 (condicao -> e BIGGER e .)
    ,               reduce using rule 43 (condicao -> e BIGGER e .)
    VARS            reduce using rule 43 (condicao -> e BIGGER e .)
    ESCREVER        reduce using rule 43 (condicao -> e BIGGER e .)
    REAL            reduce using rule 43 (condicao -> e BIGGER e .)
    INTEIRO         reduce using rule 43 (condicao -> e BIGGER e .)
    CARACTER        reduce using rule 43 (condicao -> e BIGGER e .)
    (               reduce using rule 43 (condicao -> e BIGGER e .)
    VAR             reduce using rule 43 (condicao -> e BIGGER e .)
    PARA            reduce using rule 43 (condicao -> e BIGGER e .)
    SE              reduce using rule 43 (condicao -> e BIGGER e .)
    FUNCAO          reduce using rule 43 (condicao -> e BIGGER e .)
    TRUE            reduce using rule 43 (condicao -> e BIGGER e .)
    FALSE           reduce using rule 43 (condicao -> e BIGGER e .)
    NOT             reduce using rule 43 (condicao -> e BIGGER e .)
    $end            reduce using rule 43 (condicao -> e BIGGER e .)
    FIM_SE          reduce using rule 43 (condicao -> e BIGGER e .)
    SENAO           reduce using rule 43 (condicao -> e BIGGER e .)
    FIM_FUNCAO      reduce using rule 43 (condicao -> e BIGGER e .)
    FIM             reduce using rule 43 (condicao -> e BIGGER e .)
    )               reduce using rule 43 (condicao -> e BIGGER e .)
    ENTAO           reduce using rule 43 (condicao -> e BIGGER e .)
    *               shift and go to state 27
    /               shift and go to state 28
    +               shift and go to state 29
    -               shift and go to state 30
    SMALLER         shift and go to state 34
    SMALLER_EQUAL   shift and go to state 35
    BIGGER_EQUAL    shift and go to state 37
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39

  ! *               [ reduce using rule 43 (condicao -> e BIGGER e .) ]
  ! /               [ reduce using rule 43 (condicao -> e BIGGER e .) ]
  ! +               [ reduce using rule 43 (condicao -> e BIGGER e .) ]
  ! -               [ reduce using rule 43 (condicao -> e BIGGER e .) ]
  ! SMALLER         [ reduce using rule 43 (condicao -> e BIGGER e .) ]
  ! SMALLER_EQUAL   [ reduce using rule 43 (condicao -> e BIGGER e .) ]
  ! BIGGER_EQUAL    [ reduce using rule 43 (condicao -> e BIGGER e .) ]
  ! EQUAL           [ reduce using rule 43 (condicao -> e BIGGER e .) ]
  ! NOT_EQUAL       [ reduce using rule 43 (condicao -> e BIGGER e .) ]
  ! OR              [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! XOR             [ shift and go to state 33 ]
  ! BIGGER          [ shift and go to state 36 ]


state 64

    (44) condicao -> e BIGGER_EQUAL e .
    (31) e -> e . * e
    (32) e -> e . / e
    (33) e -> e . + e
    (34) e -> e . - e
    (36) e -> e . OR e
    (37) e -> e . AND e
    (38) e -> e . XOR e
    (41) condicao -> e . SMALLER e
    (42) condicao -> e . SMALLER_EQUAL e
    (43) condicao -> e . BIGGER e
    (44) condicao -> e . BIGGER_EQUAL e
    (45) condicao -> e . EQUAL e
    (46) condicao -> e . NOT_EQUAL e

    ;               reduce using rule 44 (condicao -> e BIGGER_EQUAL e .)
    OR              reduce using rule 44 (condicao -> e BIGGER_EQUAL e .)
    AND             reduce using rule 44 (condicao -> e BIGGER_EQUAL e .)
    XOR             reduce using rule 44 (condicao -> e BIGGER_EQUAL e .)
    BIGGER          reduce using rule 44 (condicao -> e BIGGER_EQUAL e .)
    BIGGER_EQUAL    reduce using rule 44 (condicao -> e BIGGER_EQUAL e .)
    ,               reduce using rule 44 (condicao -> e BIGGER_EQUAL e .)
    VARS            reduce using rule 44 (condicao -> e BIGGER_EQUAL e .)
    ESCREVER        reduce using rule 44 (condicao -> e BIGGER_EQUAL e .)
    REAL            reduce using rule 44 (condicao -> e BIGGER_EQUAL e .)
    INTEIRO         reduce using rule 44 (condicao -> e BIGGER_EQUAL e .)
    CARACTER        reduce using rule 44 (condicao -> e BIGGER_EQUAL e .)
    (               reduce using rule 44 (condicao -> e BIGGER_EQUAL e .)
    VAR             reduce using rule 44 (condicao -> e BIGGER_EQUAL e .)
    PARA            reduce using rule 44 (condicao -> e BIGGER_EQUAL e .)
    SE              reduce using rule 44 (condicao -> e BIGGER_EQUAL e .)
    FUNCAO          reduce using rule 44 (condicao -> e BIGGER_EQUAL e .)
    TRUE            reduce using rule 44 (condicao -> e BIGGER_EQUAL e .)
    FALSE           reduce using rule 44 (condicao -> e BIGGER_EQUAL e .)
    NOT             reduce using rule 44 (condicao -> e BIGGER_EQUAL e .)
    $end            reduce using rule 44 (condicao -> e BIGGER_EQUAL e .)
    FIM_SE          reduce using rule 44 (condicao -> e BIGGER_EQUAL e .)
    SENAO           reduce using rule 44 (condicao -> e BIGGER_EQUAL e .)
    FIM_FUNCAO      reduce using rule 44 (condicao -> e BIGGER_EQUAL e .)
    FIM             reduce using rule 44 (condicao -> e BIGGER_EQUAL e .)
    )               reduce using rule 44 (condicao -> e BIGGER_EQUAL e .)
    ENTAO           reduce using rule 44 (condicao -> e BIGGER_EQUAL e .)
    *               shift and go to state 27
    /               shift and go to state 28
    +               shift and go to state 29
    -               shift and go to state 30
    SMALLER         shift and go to state 34
    SMALLER_EQUAL   shift and go to state 35
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39

  ! *               [ reduce using rule 44 (condicao -> e BIGGER_EQUAL e .) ]
  ! /               [ reduce using rule 44 (condicao -> e BIGGER_EQUAL e .) ]
  ! +               [ reduce using rule 44 (condicao -> e BIGGER_EQUAL e .) ]
  ! -               [ reduce using rule 44 (condicao -> e BIGGER_EQUAL e .) ]
  ! SMALLER         [ reduce using rule 44 (condicao -> e BIGGER_EQUAL e .) ]
  ! SMALLER_EQUAL   [ reduce using rule 44 (condicao -> e BIGGER_EQUAL e .) ]
  ! EQUAL           [ reduce using rule 44 (condicao -> e BIGGER_EQUAL e .) ]
  ! NOT_EQUAL       [ reduce using rule 44 (condicao -> e BIGGER_EQUAL e .) ]
  ! OR              [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! XOR             [ shift and go to state 33 ]
  ! BIGGER          [ shift and go to state 36 ]
  ! BIGGER_EQUAL    [ shift and go to state 37 ]


state 65

    (45) condicao -> e EQUAL e .
    (31) e -> e . * e
    (32) e -> e . / e
    (33) e -> e . + e
    (34) e -> e . - e
    (36) e -> e . OR e
    (37) e -> e . AND e
    (38) e -> e . XOR e
    (41) condicao -> e . SMALLER e
    (42) condicao -> e . SMALLER_EQUAL e
    (43) condicao -> e . BIGGER e
    (44) condicao -> e . BIGGER_EQUAL e
    (45) condicao -> e . EQUAL e
    (46) condicao -> e . NOT_EQUAL e

    ;               reduce using rule 45 (condicao -> e EQUAL e .)
    OR              reduce using rule 45 (condicao -> e EQUAL e .)
    AND             reduce using rule 45 (condicao -> e EQUAL e .)
    XOR             reduce using rule 45 (condicao -> e EQUAL e .)
    SMALLER         reduce using rule 45 (condicao -> e EQUAL e .)
    SMALLER_EQUAL   reduce using rule 45 (condicao -> e EQUAL e .)
    BIGGER          reduce using rule 45 (condicao -> e EQUAL e .)
    BIGGER_EQUAL    reduce using rule 45 (condicao -> e EQUAL e .)
    EQUAL           reduce using rule 45 (condicao -> e EQUAL e .)
    ,               reduce using rule 45 (condicao -> e EQUAL e .)
    VARS            reduce using rule 45 (condicao -> e EQUAL e .)
    ESCREVER        reduce using rule 45 (condicao -> e EQUAL e .)
    REAL            reduce using rule 45 (condicao -> e EQUAL e .)
    INTEIRO         reduce using rule 45 (condicao -> e EQUAL e .)
    CARACTER        reduce using rule 45 (condicao -> e EQUAL e .)
    (               reduce using rule 45 (condicao -> e EQUAL e .)
    VAR             reduce using rule 45 (condicao -> e EQUAL e .)
    PARA            reduce using rule 45 (condicao -> e EQUAL e .)
    SE              reduce using rule 45 (condicao -> e EQUAL e .)
    FUNCAO          reduce using rule 45 (condicao -> e EQUAL e .)
    TRUE            reduce using rule 45 (condicao -> e EQUAL e .)
    FALSE           reduce using rule 45 (condicao -> e EQUAL e .)
    NOT             reduce using rule 45 (condicao -> e EQUAL e .)
    $end            reduce using rule 45 (condicao -> e EQUAL e .)
    FIM_SE          reduce using rule 45 (condicao -> e EQUAL e .)
    SENAO           reduce using rule 45 (condicao -> e EQUAL e .)
    FIM_FUNCAO      reduce using rule 45 (condicao -> e EQUAL e .)
    FIM             reduce using rule 45 (condicao -> e EQUAL e .)
    )               reduce using rule 45 (condicao -> e EQUAL e .)
    ENTAO           reduce using rule 45 (condicao -> e EQUAL e .)
    *               shift and go to state 27
    /               shift and go to state 28
    +               shift and go to state 29
    -               shift and go to state 30
    NOT_EQUAL       shift and go to state 39

  ! *               [ reduce using rule 45 (condicao -> e EQUAL e .) ]
  ! /               [ reduce using rule 45 (condicao -> e EQUAL e .) ]
  ! +               [ reduce using rule 45 (condicao -> e EQUAL e .) ]
  ! -               [ reduce using rule 45 (condicao -> e EQUAL e .) ]
  ! NOT_EQUAL       [ reduce using rule 45 (condicao -> e EQUAL e .) ]
  ! OR              [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! XOR             [ shift and go to state 33 ]
  ! SMALLER         [ shift and go to state 34 ]
  ! SMALLER_EQUAL   [ shift and go to state 35 ]
  ! BIGGER          [ shift and go to state 36 ]
  ! BIGGER_EQUAL    [ shift and go to state 37 ]
  ! EQUAL           [ shift and go to state 38 ]


state 66

    (46) condicao -> e NOT_EQUAL e .
    (31) e -> e . * e
    (32) e -> e . / e
    (33) e -> e . + e
    (34) e -> e . - e
    (36) e -> e . OR e
    (37) e -> e . AND e
    (38) e -> e . XOR e
    (41) condicao -> e . SMALLER e
    (42) condicao -> e . SMALLER_EQUAL e
    (43) condicao -> e . BIGGER e
    (44) condicao -> e . BIGGER_EQUAL e
    (45) condicao -> e . EQUAL e
    (46) condicao -> e . NOT_EQUAL e

    ;               reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    OR              reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    AND             reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    XOR             reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    SMALLER         reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    SMALLER_EQUAL   reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    BIGGER          reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    BIGGER_EQUAL    reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    EQUAL           reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    NOT_EQUAL       reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    ,               reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    VARS            reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    ESCREVER        reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    REAL            reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    INTEIRO         reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    CARACTER        reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    (               reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    VAR             reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    PARA            reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    SE              reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    FUNCAO          reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    TRUE            reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    FALSE           reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    NOT             reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    $end            reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    FIM_SE          reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    SENAO           reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    FIM_FUNCAO      reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    FIM             reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    )               reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    ENTAO           reduce using rule 46 (condicao -> e NOT_EQUAL e .)
    *               shift and go to state 27
    /               shift and go to state 28
    +               shift and go to state 29
    -               shift and go to state 30

  ! *               [ reduce using rule 46 (condicao -> e NOT_EQUAL e .) ]
  ! /               [ reduce using rule 46 (condicao -> e NOT_EQUAL e .) ]
  ! +               [ reduce using rule 46 (condicao -> e NOT_EQUAL e .) ]
  ! -               [ reduce using rule 46 (condicao -> e NOT_EQUAL e .) ]
  ! OR              [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! XOR             [ shift and go to state 33 ]
  ! SMALLER         [ shift and go to state 34 ]
  ! SMALLER_EQUAL   [ shift and go to state 35 ]
  ! BIGGER          [ shift and go to state 36 ]
  ! BIGGER_EQUAL    [ shift and go to state 37 ]
  ! EQUAL           [ shift and go to state 38 ]
  ! NOT_EQUAL       [ shift and go to state 39 ]


state 67

    (9) command -> VARS VAR ATRIBUICAO . var_list ;
    (22) var_list -> . VAR
    (23) var_list -> . var_list , VAR

    VAR             shift and go to state 76

    var_list                       shift and go to state 77

state 68

    (17) callfunc -> VAR ( e_list . )
    (25) e_list -> e_list . , e

    )               shift and go to state 78
    ,               shift and go to state 71


state 69

    (18) callfunc -> VAR ( ) .

    ;               reduce using rule 18 (callfunc -> VAR ( ) .)


state 70

    (23) var_list -> var_list , . VAR

    VAR             shift and go to state 79


state 71

    (25) e_list -> e_list , . e
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 48
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    e                              shift and go to state 80
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 72

    (39) e -> ( e ) .

    ;               reduce using rule 39 (e -> ( e ) .)
    *               reduce using rule 39 (e -> ( e ) .)
    /               reduce using rule 39 (e -> ( e ) .)
    +               reduce using rule 39 (e -> ( e ) .)
    -               reduce using rule 39 (e -> ( e ) .)
    OR              reduce using rule 39 (e -> ( e ) .)
    AND             reduce using rule 39 (e -> ( e ) .)
    XOR             reduce using rule 39 (e -> ( e ) .)
    SMALLER         reduce using rule 39 (e -> ( e ) .)
    SMALLER_EQUAL   reduce using rule 39 (e -> ( e ) .)
    BIGGER          reduce using rule 39 (e -> ( e ) .)
    BIGGER_EQUAL    reduce using rule 39 (e -> ( e ) .)
    EQUAL           reduce using rule 39 (e -> ( e ) .)
    NOT_EQUAL       reduce using rule 39 (e -> ( e ) .)
    ,               reduce using rule 39 (e -> ( e ) .)
    VARS            reduce using rule 39 (e -> ( e ) .)
    ESCREVER        reduce using rule 39 (e -> ( e ) .)
    REAL            reduce using rule 39 (e -> ( e ) .)
    INTEIRO         reduce using rule 39 (e -> ( e ) .)
    CARACTER        reduce using rule 39 (e -> ( e ) .)
    (               reduce using rule 39 (e -> ( e ) .)
    VAR             reduce using rule 39 (e -> ( e ) .)
    PARA            reduce using rule 39 (e -> ( e ) .)
    SE              reduce using rule 39 (e -> ( e ) .)
    FUNCAO          reduce using rule 39 (e -> ( e ) .)
    TRUE            reduce using rule 39 (e -> ( e ) .)
    FALSE           reduce using rule 39 (e -> ( e ) .)
    NOT             reduce using rule 39 (e -> ( e ) .)
    $end            reduce using rule 39 (e -> ( e ) .)
    FIM_SE          reduce using rule 39 (e -> ( e ) .)
    SENAO           reduce using rule 39 (e -> ( e ) .)
    FIM_FUNCAO      reduce using rule 39 (e -> ( e ) .)
    FIM             reduce using rule 39 (e -> ( e ) .)
    )               reduce using rule 39 (e -> ( e ) .)
    ENTAO           reduce using rule 39 (e -> ( e ) .)


state 73

    (12) ciclo_for -> PARA VARS EM . [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM

    [               shift and go to state 81


state 74

    (13) if -> SE e ENTAO . com_list FIM_SE
    (14) if -> SE e ENTAO . com_list SENAO com_list FIM_SE
    (2) com_list -> . command
    (3) com_list -> . com_list command
    (4) command -> . e ;
    (5) command -> . ciclo_for
    (6) command -> . callfunc ;
    (7) command -> . if
    (8) command -> . func
    (9) command -> . VARS VAR ATRIBUICAO var_list ;
    (10) command -> . ESCREVER var_list
    (11) command -> . ESCREVER e_list
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (12) ciclo_for -> . PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM
    (17) callfunc -> . VAR ( e_list )
    (18) callfunc -> . VAR ( )
    (13) if -> . SE e ENTAO com_list FIM_SE
    (14) if -> . SE e ENTAO com_list SENAO com_list FIM_SE
    (15) func -> . FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO
    (16) func -> . FUNCAO VAR ( ) com_list FIM_FUNCAO
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    VARS            shift and go to state 9
    ESCREVER        shift and go to state 11
    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 10
    PARA            shift and go to state 19
    SE              shift and go to state 20
    FUNCAO          shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    e                              shift and go to state 4
    com_list                       shift and go to state 82
    command                        shift and go to state 3
    ciclo_for                      shift and go to state 5
    callfunc                       shift and go to state 6
    if                             shift and go to state 7
    func                           shift and go to state 8
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 75

    (15) func -> FUNCAO VAR ( . var_fun_list ) com_list FIM_FUNCAO
    (16) func -> FUNCAO VAR ( . ) com_list FIM_FUNCAO
    (19) var_fun_list -> . var_fun
    (20) var_fun_list -> . var_fun_list , var_fun
    (21) var_fun -> . type VAR
    (47) type -> . DEFINITION_INTEIRO
    (48) type -> . DEFINITION_REAL
    (49) type -> . DEFINITION_CARACTER
    (50) type -> . DEFENITION_LOGICO

    )               shift and go to state 84
    DEFINITION_INTEIRO shift and go to state 87
    DEFINITION_REAL shift and go to state 88
    DEFINITION_CARACTER shift and go to state 89
    DEFENITION_LOGICO shift and go to state 90

    var_fun_list                   shift and go to state 83
    var_fun                        shift and go to state 85
    type                           shift and go to state 86

state 76

    (22) var_list -> VAR .

    ;               reduce using rule 22 (var_list -> VAR .)
    ,               reduce using rule 22 (var_list -> VAR .)


state 77

    (9) command -> VARS VAR ATRIBUICAO var_list . ;
    (23) var_list -> var_list . , VAR

    ;               shift and go to state 91
    ,               shift and go to state 70


state 78

    (17) callfunc -> VAR ( e_list ) .

    ;               reduce using rule 17 (callfunc -> VAR ( e_list ) .)


state 79

    (23) var_list -> var_list , VAR .

    ,               reduce using rule 23 (var_list -> var_list , VAR .)
    VARS            reduce using rule 23 (var_list -> var_list , VAR .)
    ESCREVER        reduce using rule 23 (var_list -> var_list , VAR .)
    REAL            reduce using rule 23 (var_list -> var_list , VAR .)
    INTEIRO         reduce using rule 23 (var_list -> var_list , VAR .)
    CARACTER        reduce using rule 23 (var_list -> var_list , VAR .)
    -               reduce using rule 23 (var_list -> var_list , VAR .)
    (               reduce using rule 23 (var_list -> var_list , VAR .)
    VAR             reduce using rule 23 (var_list -> var_list , VAR .)
    PARA            reduce using rule 23 (var_list -> var_list , VAR .)
    SE              reduce using rule 23 (var_list -> var_list , VAR .)
    FUNCAO          reduce using rule 23 (var_list -> var_list , VAR .)
    TRUE            reduce using rule 23 (var_list -> var_list , VAR .)
    FALSE           reduce using rule 23 (var_list -> var_list , VAR .)
    NOT             reduce using rule 23 (var_list -> var_list , VAR .)
    $end            reduce using rule 23 (var_list -> var_list , VAR .)
    FIM_SE          reduce using rule 23 (var_list -> var_list , VAR .)
    SENAO           reduce using rule 23 (var_list -> var_list , VAR .)
    FIM_FUNCAO      reduce using rule 23 (var_list -> var_list , VAR .)
    FIM             reduce using rule 23 (var_list -> var_list , VAR .)
    ;               reduce using rule 23 (var_list -> var_list , VAR .)


state 80

    (25) e_list -> e_list , e .
    (31) e -> e . * e
    (32) e -> e . / e
    (33) e -> e . + e
    (34) e -> e . - e
    (36) e -> e . OR e
    (37) e -> e . AND e
    (38) e -> e . XOR e
    (41) condicao -> e . SMALLER e
    (42) condicao -> e . SMALLER_EQUAL e
    (43) condicao -> e . BIGGER e
    (44) condicao -> e . BIGGER_EQUAL e
    (45) condicao -> e . EQUAL e
    (46) condicao -> e . NOT_EQUAL e

  ! shift/reduce conflict for - resolved as shift
    ,               reduce using rule 25 (e_list -> e_list , e .)
    VARS            reduce using rule 25 (e_list -> e_list , e .)
    ESCREVER        reduce using rule 25 (e_list -> e_list , e .)
    REAL            reduce using rule 25 (e_list -> e_list , e .)
    INTEIRO         reduce using rule 25 (e_list -> e_list , e .)
    CARACTER        reduce using rule 25 (e_list -> e_list , e .)
    (               reduce using rule 25 (e_list -> e_list , e .)
    VAR             reduce using rule 25 (e_list -> e_list , e .)
    PARA            reduce using rule 25 (e_list -> e_list , e .)
    SE              reduce using rule 25 (e_list -> e_list , e .)
    FUNCAO          reduce using rule 25 (e_list -> e_list , e .)
    TRUE            reduce using rule 25 (e_list -> e_list , e .)
    FALSE           reduce using rule 25 (e_list -> e_list , e .)
    NOT             reduce using rule 25 (e_list -> e_list , e .)
    $end            reduce using rule 25 (e_list -> e_list , e .)
    FIM_SE          reduce using rule 25 (e_list -> e_list , e .)
    SENAO           reduce using rule 25 (e_list -> e_list , e .)
    FIM_FUNCAO      reduce using rule 25 (e_list -> e_list , e .)
    FIM             reduce using rule 25 (e_list -> e_list , e .)
    )               reduce using rule 25 (e_list -> e_list , e .)
    *               shift and go to state 27
    /               shift and go to state 28
    +               shift and go to state 29
    -               shift and go to state 30
    OR              shift and go to state 31
    AND             shift and go to state 32
    XOR             shift and go to state 33
    SMALLER         shift and go to state 34
    SMALLER_EQUAL   shift and go to state 35
    BIGGER          shift and go to state 36
    BIGGER_EQUAL    shift and go to state 37
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39

  ! -               [ reduce using rule 25 (e_list -> e_list , e .) ]


state 81

    (12) ciclo_for -> PARA VARS EM [ . INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM

    INTEIRO         shift and go to state 92


state 82

    (13) if -> SE e ENTAO com_list . FIM_SE
    (14) if -> SE e ENTAO com_list . SENAO com_list FIM_SE
    (3) com_list -> com_list . command
    (4) command -> . e ;
    (5) command -> . ciclo_for
    (6) command -> . callfunc ;
    (7) command -> . if
    (8) command -> . func
    (9) command -> . VARS VAR ATRIBUICAO var_list ;
    (10) command -> . ESCREVER var_list
    (11) command -> . ESCREVER e_list
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (12) ciclo_for -> . PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM
    (17) callfunc -> . VAR ( e_list )
    (18) callfunc -> . VAR ( )
    (13) if -> . SE e ENTAO com_list FIM_SE
    (14) if -> . SE e ENTAO com_list SENAO com_list FIM_SE
    (15) func -> . FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO
    (16) func -> . FUNCAO VAR ( ) com_list FIM_FUNCAO
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    FIM_SE          shift and go to state 93
    SENAO           shift and go to state 94
    VARS            shift and go to state 9
    ESCREVER        shift and go to state 11
    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 10
    PARA            shift and go to state 19
    SE              shift and go to state 20
    FUNCAO          shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    e                              shift and go to state 4
    command                        shift and go to state 25
    ciclo_for                      shift and go to state 5
    callfunc                       shift and go to state 6
    if                             shift and go to state 7
    func                           shift and go to state 8
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 83

    (15) func -> FUNCAO VAR ( var_fun_list . ) com_list FIM_FUNCAO
    (20) var_fun_list -> var_fun_list . , var_fun

    )               shift and go to state 95
    ,               shift and go to state 96


state 84

    (16) func -> FUNCAO VAR ( ) . com_list FIM_FUNCAO
    (2) com_list -> . command
    (3) com_list -> . com_list command
    (4) command -> . e ;
    (5) command -> . ciclo_for
    (6) command -> . callfunc ;
    (7) command -> . if
    (8) command -> . func
    (9) command -> . VARS VAR ATRIBUICAO var_list ;
    (10) command -> . ESCREVER var_list
    (11) command -> . ESCREVER e_list
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (12) ciclo_for -> . PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM
    (17) callfunc -> . VAR ( e_list )
    (18) callfunc -> . VAR ( )
    (13) if -> . SE e ENTAO com_list FIM_SE
    (14) if -> . SE e ENTAO com_list SENAO com_list FIM_SE
    (15) func -> . FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO
    (16) func -> . FUNCAO VAR ( ) com_list FIM_FUNCAO
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    VARS            shift and go to state 9
    ESCREVER        shift and go to state 11
    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 10
    PARA            shift and go to state 19
    SE              shift and go to state 20
    FUNCAO          shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    com_list                       shift and go to state 97
    command                        shift and go to state 3
    e                              shift and go to state 4
    ciclo_for                      shift and go to state 5
    callfunc                       shift and go to state 6
    if                             shift and go to state 7
    func                           shift and go to state 8
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 85

    (19) var_fun_list -> var_fun .

    )               reduce using rule 19 (var_fun_list -> var_fun .)
    ,               reduce using rule 19 (var_fun_list -> var_fun .)


state 86

    (21) var_fun -> type . VAR

    VAR             shift and go to state 98


state 87

    (47) type -> DEFINITION_INTEIRO .

    VAR             reduce using rule 47 (type -> DEFINITION_INTEIRO .)


state 88

    (48) type -> DEFINITION_REAL .

    VAR             reduce using rule 48 (type -> DEFINITION_REAL .)


state 89

    (49) type -> DEFINITION_CARACTER .

    VAR             reduce using rule 49 (type -> DEFINITION_CARACTER .)


state 90

    (50) type -> DEFENITION_LOGICO .

    VAR             reduce using rule 50 (type -> DEFENITION_LOGICO .)


state 91

    (9) command -> VARS VAR ATRIBUICAO var_list ; .

    VARS            reduce using rule 9 (command -> VARS VAR ATRIBUICAO var_list ; .)
    ESCREVER        reduce using rule 9 (command -> VARS VAR ATRIBUICAO var_list ; .)
    REAL            reduce using rule 9 (command -> VARS VAR ATRIBUICAO var_list ; .)
    INTEIRO         reduce using rule 9 (command -> VARS VAR ATRIBUICAO var_list ; .)
    CARACTER        reduce using rule 9 (command -> VARS VAR ATRIBUICAO var_list ; .)
    -               reduce using rule 9 (command -> VARS VAR ATRIBUICAO var_list ; .)
    (               reduce using rule 9 (command -> VARS VAR ATRIBUICAO var_list ; .)
    VAR             reduce using rule 9 (command -> VARS VAR ATRIBUICAO var_list ; .)
    PARA            reduce using rule 9 (command -> VARS VAR ATRIBUICAO var_list ; .)
    SE              reduce using rule 9 (command -> VARS VAR ATRIBUICAO var_list ; .)
    FUNCAO          reduce using rule 9 (command -> VARS VAR ATRIBUICAO var_list ; .)
    TRUE            reduce using rule 9 (command -> VARS VAR ATRIBUICAO var_list ; .)
    FALSE           reduce using rule 9 (command -> VARS VAR ATRIBUICAO var_list ; .)
    NOT             reduce using rule 9 (command -> VARS VAR ATRIBUICAO var_list ; .)
    $end            reduce using rule 9 (command -> VARS VAR ATRIBUICAO var_list ; .)
    FIM_SE          reduce using rule 9 (command -> VARS VAR ATRIBUICAO var_list ; .)
    SENAO           reduce using rule 9 (command -> VARS VAR ATRIBUICAO var_list ; .)
    FIM_FUNCAO      reduce using rule 9 (command -> VARS VAR ATRIBUICAO var_list ; .)
    FIM             reduce using rule 9 (command -> VARS VAR ATRIBUICAO var_list ; .)


state 92

    (12) ciclo_for -> PARA VARS EM [ INTEIRO . ELIPSIS INTEIRO ] FAZER com_list FIM

    ELIPSIS         shift and go to state 99


state 93

    (13) if -> SE e ENTAO com_list FIM_SE .

    VARS            reduce using rule 13 (if -> SE e ENTAO com_list FIM_SE .)
    ESCREVER        reduce using rule 13 (if -> SE e ENTAO com_list FIM_SE .)
    REAL            reduce using rule 13 (if -> SE e ENTAO com_list FIM_SE .)
    INTEIRO         reduce using rule 13 (if -> SE e ENTAO com_list FIM_SE .)
    CARACTER        reduce using rule 13 (if -> SE e ENTAO com_list FIM_SE .)
    -               reduce using rule 13 (if -> SE e ENTAO com_list FIM_SE .)
    (               reduce using rule 13 (if -> SE e ENTAO com_list FIM_SE .)
    VAR             reduce using rule 13 (if -> SE e ENTAO com_list FIM_SE .)
    PARA            reduce using rule 13 (if -> SE e ENTAO com_list FIM_SE .)
    SE              reduce using rule 13 (if -> SE e ENTAO com_list FIM_SE .)
    FUNCAO          reduce using rule 13 (if -> SE e ENTAO com_list FIM_SE .)
    TRUE            reduce using rule 13 (if -> SE e ENTAO com_list FIM_SE .)
    FALSE           reduce using rule 13 (if -> SE e ENTAO com_list FIM_SE .)
    NOT             reduce using rule 13 (if -> SE e ENTAO com_list FIM_SE .)
    $end            reduce using rule 13 (if -> SE e ENTAO com_list FIM_SE .)
    FIM_SE          reduce using rule 13 (if -> SE e ENTAO com_list FIM_SE .)
    SENAO           reduce using rule 13 (if -> SE e ENTAO com_list FIM_SE .)
    FIM_FUNCAO      reduce using rule 13 (if -> SE e ENTAO com_list FIM_SE .)
    FIM             reduce using rule 13 (if -> SE e ENTAO com_list FIM_SE .)


state 94

    (14) if -> SE e ENTAO com_list SENAO . com_list FIM_SE
    (2) com_list -> . command
    (3) com_list -> . com_list command
    (4) command -> . e ;
    (5) command -> . ciclo_for
    (6) command -> . callfunc ;
    (7) command -> . if
    (8) command -> . func
    (9) command -> . VARS VAR ATRIBUICAO var_list ;
    (10) command -> . ESCREVER var_list
    (11) command -> . ESCREVER e_list
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (12) ciclo_for -> . PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM
    (17) callfunc -> . VAR ( e_list )
    (18) callfunc -> . VAR ( )
    (13) if -> . SE e ENTAO com_list FIM_SE
    (14) if -> . SE e ENTAO com_list SENAO com_list FIM_SE
    (15) func -> . FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO
    (16) func -> . FUNCAO VAR ( ) com_list FIM_FUNCAO
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    VARS            shift and go to state 9
    ESCREVER        shift and go to state 11
    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 10
    PARA            shift and go to state 19
    SE              shift and go to state 20
    FUNCAO          shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    e                              shift and go to state 4
    com_list                       shift and go to state 100
    command                        shift and go to state 3
    ciclo_for                      shift and go to state 5
    callfunc                       shift and go to state 6
    if                             shift and go to state 7
    func                           shift and go to state 8
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 95

    (15) func -> FUNCAO VAR ( var_fun_list ) . com_list FIM_FUNCAO
    (2) com_list -> . command
    (3) com_list -> . com_list command
    (4) command -> . e ;
    (5) command -> . ciclo_for
    (6) command -> . callfunc ;
    (7) command -> . if
    (8) command -> . func
    (9) command -> . VARS VAR ATRIBUICAO var_list ;
    (10) command -> . ESCREVER var_list
    (11) command -> . ESCREVER e_list
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (12) ciclo_for -> . PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM
    (17) callfunc -> . VAR ( e_list )
    (18) callfunc -> . VAR ( )
    (13) if -> . SE e ENTAO com_list FIM_SE
    (14) if -> . SE e ENTAO com_list SENAO com_list FIM_SE
    (15) func -> . FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO
    (16) func -> . FUNCAO VAR ( ) com_list FIM_FUNCAO
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    VARS            shift and go to state 9
    ESCREVER        shift and go to state 11
    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 10
    PARA            shift and go to state 19
    SE              shift and go to state 20
    FUNCAO          shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    com_list                       shift and go to state 101
    command                        shift and go to state 3
    e                              shift and go to state 4
    ciclo_for                      shift and go to state 5
    callfunc                       shift and go to state 6
    if                             shift and go to state 7
    func                           shift and go to state 8
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 96

    (20) var_fun_list -> var_fun_list , . var_fun
    (21) var_fun -> . type VAR
    (47) type -> . DEFINITION_INTEIRO
    (48) type -> . DEFINITION_REAL
    (49) type -> . DEFINITION_CARACTER
    (50) type -> . DEFENITION_LOGICO

    DEFINITION_INTEIRO shift and go to state 87
    DEFINITION_REAL shift and go to state 88
    DEFINITION_CARACTER shift and go to state 89
    DEFENITION_LOGICO shift and go to state 90

    var_fun                        shift and go to state 102
    type                           shift and go to state 86

state 97

    (16) func -> FUNCAO VAR ( ) com_list . FIM_FUNCAO
    (3) com_list -> com_list . command
    (4) command -> . e ;
    (5) command -> . ciclo_for
    (6) command -> . callfunc ;
    (7) command -> . if
    (8) command -> . func
    (9) command -> . VARS VAR ATRIBUICAO var_list ;
    (10) command -> . ESCREVER var_list
    (11) command -> . ESCREVER e_list
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (12) ciclo_for -> . PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM
    (17) callfunc -> . VAR ( e_list )
    (18) callfunc -> . VAR ( )
    (13) if -> . SE e ENTAO com_list FIM_SE
    (14) if -> . SE e ENTAO com_list SENAO com_list FIM_SE
    (15) func -> . FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO
    (16) func -> . FUNCAO VAR ( ) com_list FIM_FUNCAO
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    FIM_FUNCAO      shift and go to state 103
    VARS            shift and go to state 9
    ESCREVER        shift and go to state 11
    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 10
    PARA            shift and go to state 19
    SE              shift and go to state 20
    FUNCAO          shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    command                        shift and go to state 25
    e                              shift and go to state 4
    ciclo_for                      shift and go to state 5
    callfunc                       shift and go to state 6
    if                             shift and go to state 7
    func                           shift and go to state 8
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 98

    (21) var_fun -> type VAR .

    )               reduce using rule 21 (var_fun -> type VAR .)
    ,               reduce using rule 21 (var_fun -> type VAR .)


state 99

    (12) ciclo_for -> PARA VARS EM [ INTEIRO ELIPSIS . INTEIRO ] FAZER com_list FIM

    INTEIRO         shift and go to state 104


state 100

    (14) if -> SE e ENTAO com_list SENAO com_list . FIM_SE
    (3) com_list -> com_list . command
    (4) command -> . e ;
    (5) command -> . ciclo_for
    (6) command -> . callfunc ;
    (7) command -> . if
    (8) command -> . func
    (9) command -> . VARS VAR ATRIBUICAO var_list ;
    (10) command -> . ESCREVER var_list
    (11) command -> . ESCREVER e_list
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (12) ciclo_for -> . PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM
    (17) callfunc -> . VAR ( e_list )
    (18) callfunc -> . VAR ( )
    (13) if -> . SE e ENTAO com_list FIM_SE
    (14) if -> . SE e ENTAO com_list SENAO com_list FIM_SE
    (15) func -> . FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO
    (16) func -> . FUNCAO VAR ( ) com_list FIM_FUNCAO
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    FIM_SE          shift and go to state 105
    VARS            shift and go to state 9
    ESCREVER        shift and go to state 11
    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 10
    PARA            shift and go to state 19
    SE              shift and go to state 20
    FUNCAO          shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    e                              shift and go to state 4
    command                        shift and go to state 25
    ciclo_for                      shift and go to state 5
    callfunc                       shift and go to state 6
    if                             shift and go to state 7
    func                           shift and go to state 8
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 101

    (15) func -> FUNCAO VAR ( var_fun_list ) com_list . FIM_FUNCAO
    (3) com_list -> com_list . command
    (4) command -> . e ;
    (5) command -> . ciclo_for
    (6) command -> . callfunc ;
    (7) command -> . if
    (8) command -> . func
    (9) command -> . VARS VAR ATRIBUICAO var_list ;
    (10) command -> . ESCREVER var_list
    (11) command -> . ESCREVER e_list
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (12) ciclo_for -> . PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM
    (17) callfunc -> . VAR ( e_list )
    (18) callfunc -> . VAR ( )
    (13) if -> . SE e ENTAO com_list FIM_SE
    (14) if -> . SE e ENTAO com_list SENAO com_list FIM_SE
    (15) func -> . FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO
    (16) func -> . FUNCAO VAR ( ) com_list FIM_FUNCAO
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    FIM_FUNCAO      shift and go to state 106
    VARS            shift and go to state 9
    ESCREVER        shift and go to state 11
    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 10
    PARA            shift and go to state 19
    SE              shift and go to state 20
    FUNCAO          shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    command                        shift and go to state 25
    e                              shift and go to state 4
    ciclo_for                      shift and go to state 5
    callfunc                       shift and go to state 6
    if                             shift and go to state 7
    func                           shift and go to state 8
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 102

    (20) var_fun_list -> var_fun_list , var_fun .

    )               reduce using rule 20 (var_fun_list -> var_fun_list , var_fun .)
    ,               reduce using rule 20 (var_fun_list -> var_fun_list , var_fun .)


state 103

    (16) func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .

    VARS            reduce using rule 16 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    ESCREVER        reduce using rule 16 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    REAL            reduce using rule 16 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    INTEIRO         reduce using rule 16 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    CARACTER        reduce using rule 16 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    -               reduce using rule 16 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    (               reduce using rule 16 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    VAR             reduce using rule 16 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    PARA            reduce using rule 16 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    SE              reduce using rule 16 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    FUNCAO          reduce using rule 16 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    TRUE            reduce using rule 16 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    FALSE           reduce using rule 16 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    NOT             reduce using rule 16 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    $end            reduce using rule 16 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    FIM_SE          reduce using rule 16 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    SENAO           reduce using rule 16 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    FIM_FUNCAO      reduce using rule 16 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    FIM             reduce using rule 16 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)


state 104

    (12) ciclo_for -> PARA VARS EM [ INTEIRO ELIPSIS INTEIRO . ] FAZER com_list FIM

    ]               shift and go to state 107


state 105

    (14) if -> SE e ENTAO com_list SENAO com_list FIM_SE .

    VARS            reduce using rule 14 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    ESCREVER        reduce using rule 14 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    REAL            reduce using rule 14 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    INTEIRO         reduce using rule 14 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    CARACTER        reduce using rule 14 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    -               reduce using rule 14 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    (               reduce using rule 14 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    VAR             reduce using rule 14 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    PARA            reduce using rule 14 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    SE              reduce using rule 14 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    FUNCAO          reduce using rule 14 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    TRUE            reduce using rule 14 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    FALSE           reduce using rule 14 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    NOT             reduce using rule 14 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    $end            reduce using rule 14 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    FIM_SE          reduce using rule 14 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    SENAO           reduce using rule 14 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    FIM_FUNCAO      reduce using rule 14 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    FIM             reduce using rule 14 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)


state 106

    (15) func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .

    VARS            reduce using rule 15 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    ESCREVER        reduce using rule 15 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    REAL            reduce using rule 15 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    INTEIRO         reduce using rule 15 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    CARACTER        reduce using rule 15 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    -               reduce using rule 15 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    (               reduce using rule 15 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    VAR             reduce using rule 15 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    PARA            reduce using rule 15 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    SE              reduce using rule 15 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    FUNCAO          reduce using rule 15 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    TRUE            reduce using rule 15 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    FALSE           reduce using rule 15 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    NOT             reduce using rule 15 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    $end            reduce using rule 15 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    FIM_SE          reduce using rule 15 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    SENAO           reduce using rule 15 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    FIM_FUNCAO      reduce using rule 15 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    FIM             reduce using rule 15 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)


state 107

    (12) ciclo_for -> PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] . FAZER com_list FIM

    FAZER           shift and go to state 108


state 108

    (12) ciclo_for -> PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER . com_list FIM
    (2) com_list -> . command
    (3) com_list -> . com_list command
    (4) command -> . e ;
    (5) command -> . ciclo_for
    (6) command -> . callfunc ;
    (7) command -> . if
    (8) command -> . func
    (9) command -> . VARS VAR ATRIBUICAO var_list ;
    (10) command -> . ESCREVER var_list
    (11) command -> . ESCREVER e_list
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (12) ciclo_for -> . PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM
    (17) callfunc -> . VAR ( e_list )
    (18) callfunc -> . VAR ( )
    (13) if -> . SE e ENTAO com_list FIM_SE
    (14) if -> . SE e ENTAO com_list SENAO com_list FIM_SE
    (15) func -> . FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO
    (16) func -> . FUNCAO VAR ( ) com_list FIM_FUNCAO
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    VARS            shift and go to state 9
    ESCREVER        shift and go to state 11
    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 10
    PARA            shift and go to state 19
    SE              shift and go to state 20
    FUNCAO          shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    com_list                       shift and go to state 109
    command                        shift and go to state 3
    e                              shift and go to state 4
    ciclo_for                      shift and go to state 5
    callfunc                       shift and go to state 6
    if                             shift and go to state 7
    func                           shift and go to state 8
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 109

    (12) ciclo_for -> PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list . FIM
    (3) com_list -> com_list . command
    (4) command -> . e ;
    (5) command -> . ciclo_for
    (6) command -> . callfunc ;
    (7) command -> . if
    (8) command -> . func
    (9) command -> . VARS VAR ATRIBUICAO var_list ;
    (10) command -> . ESCREVER var_list
    (11) command -> . ESCREVER e_list
    (26) e -> . REAL
    (27) e -> . INTEIRO
    (28) e -> . CARACTER
    (29) e -> . condicao
    (30) e -> . - e
    (31) e -> . e * e
    (32) e -> . e / e
    (33) e -> . e + e
    (34) e -> . e - e
    (35) e -> . logico
    (36) e -> . e OR e
    (37) e -> . e AND e
    (38) e -> . e XOR e
    (39) e -> . ( e )
    (40) e -> . VAR
    (12) ciclo_for -> . PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM
    (17) callfunc -> . VAR ( e_list )
    (18) callfunc -> . VAR ( )
    (13) if -> . SE e ENTAO com_list FIM_SE
    (14) if -> . SE e ENTAO com_list SENAO com_list FIM_SE
    (15) func -> . FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO
    (16) func -> . FUNCAO VAR ( ) com_list FIM_FUNCAO
    (41) condicao -> . e SMALLER e
    (42) condicao -> . e SMALLER_EQUAL e
    (43) condicao -> . e BIGGER e
    (44) condicao -> . e BIGGER_EQUAL e
    (45) condicao -> . e EQUAL e
    (46) condicao -> . e NOT_EQUAL e
    (51) logico -> . TRUE
    (52) logico -> . FALSE
    (53) logico -> . NOT logico

    FIM             shift and go to state 110
    VARS            shift and go to state 9
    ESCREVER        shift and go to state 11
    REAL            shift and go to state 12
    INTEIRO         shift and go to state 13
    CARACTER        shift and go to state 14
    -               shift and go to state 16
    (               shift and go to state 18
    VAR             shift and go to state 10
    PARA            shift and go to state 19
    SE              shift and go to state 20
    FUNCAO          shift and go to state 21
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24

    command                        shift and go to state 25
    e                              shift and go to state 4
    ciclo_for                      shift and go to state 5
    callfunc                       shift and go to state 6
    if                             shift and go to state 7
    func                           shift and go to state 8
    condicao                       shift and go to state 15
    logico                         shift and go to state 17

state 110

    (12) ciclo_for -> PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .

    VARS            reduce using rule 12 (ciclo_for -> PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    ESCREVER        reduce using rule 12 (ciclo_for -> PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    REAL            reduce using rule 12 (ciclo_for -> PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    INTEIRO         reduce using rule 12 (ciclo_for -> PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    CARACTER        reduce using rule 12 (ciclo_for -> PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    -               reduce using rule 12 (ciclo_for -> PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    (               reduce using rule 12 (ciclo_for -> PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    VAR             reduce using rule 12 (ciclo_for -> PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    PARA            reduce using rule 12 (ciclo_for -> PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    SE              reduce using rule 12 (ciclo_for -> PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    FUNCAO          reduce using rule 12 (ciclo_for -> PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    TRUE            reduce using rule 12 (ciclo_for -> PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    FALSE           reduce using rule 12 (ciclo_for -> PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    NOT             reduce using rule 12 (ciclo_for -> PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    $end            reduce using rule 12 (ciclo_for -> PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    FIM_SE          reduce using rule 12 (ciclo_for -> PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    SENAO           reduce using rule 12 (ciclo_for -> PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    FIM_FUNCAO      reduce using rule 12 (ciclo_for -> PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    FIM             reduce using rule 12 (ciclo_for -> PARA VARS EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for - in state 46 resolved as shift
WARNING: shift/reduce conflict for - in state 80 resolved as shift
WARNING: reduce/reduce conflict in state 45 resolved using rule (var_list -> VAR)
WARNING: rejected rule (e -> VAR) in state 45
