Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> S
Rule 1     S -> LstV ;
Rule 2     LstV -> LstV ; command
Rule 3     LstV -> com_list
Rule 4     com_list -> command
Rule 5     com_list -> com_list command
Rule 6     command -> V STRING ATRIBUICAO var_list
Rule 7     command -> ESCREVER STRING ;
Rule 8     command -> ESCREVER e
Rule 9     command -> ESCREVER var_list
Rule 10    command -> ID ATRIBUICAO e_list
Rule 11    command -> ciclo_for
Rule 12    command -> callfunc ;
Rule 13    command -> if
Rule 14    command -> func
Rule 15    ciclo_for -> PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM
Rule 16    if -> SE e ENTAO com_list FIM_SE
Rule 17    if -> SE e ENTAO com_list SENAO com_list FIM_SE
Rule 18    func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO
Rule 19    func -> FUNCAO VAR ( ) com_list FIM_FUNCAO
Rule 20    callfunc -> VAR ( e_list )
Rule 21    callfunc -> VAR ( )
Rule 22    var_fun_list -> var_fun
Rule 23    var_fun_list -> var_fun_list , var_fun
Rule 24    var_fun -> type VAR
Rule 25    var_list -> VAR
Rule 26    var_list -> var_list , VAR
Rule 27    e_list -> e
Rule 28    e_list -> e_list , e
Rule 29    e -> ID
Rule 30    e -> REAL
Rule 31    e -> INTEIRO
Rule 32    e -> CARACTER
Rule 33    e -> condicao
Rule 34    e -> - e
Rule 35    e -> e * e
Rule 36    e -> e / e
Rule 37    e -> e + e
Rule 38    e -> e - e
Rule 39    e -> logico
Rule 40    e -> e OR e
Rule 41    e -> e AND e
Rule 42    e -> e XOR e
Rule 43    e -> ( e )
Rule 44    condicao -> e SMALLER e
Rule 45    condicao -> e SMALLER_EQUAL e
Rule 46    condicao -> e BIGGER e
Rule 47    condicao -> e BIGGER_EQUAL e
Rule 48    condicao -> e EQUAL e
Rule 49    condicao -> e NOT_EQUAL e
Rule 50    type -> DEFINITION_INTEIRO
Rule 51    type -> DEFINITION_REAL
Rule 52    type -> DEFINITION_CARACTER
Rule 53    type -> DEFENITION_LOGICO
Rule 54    logico -> TRUE
Rule 55    logico -> FALSE
Rule 56    logico -> NOT logico

Terminals, with rules where they appear

(                    : 18 19 20 21 43
)                    : 18 19 20 21 43
*                    : 35
+                    : 37
,                    : 23 26 28
-                    : 34 38
/                    : 36
;                    : 1 2 7 12
AND                  : 41
ATRIBUICAO           : 6 10
BIGGER               : 46
BIGGER_EQUAL         : 47
CARACTER             : 32
DEFENITION_LOGICO    : 53
DEFINITION_CARACTER  : 52
DEFINITION_INTEIRO   : 50
DEFINITION_REAL      : 51
ELIPSIS              : 15
EM                   : 15
ENTAO                : 16 17
EQUAL                : 48
ESCREVER             : 7 8 9
FALSE                : 55
FAZER                : 15
FIM                  : 15
FIM_FUNCAO           : 18 19
FIM_SE               : 16 17
FUNCAO               : 18 19
ID                   : 10 15 29
INTEIRO              : 15 15 31
NOT                  : 56
NOT_EQUAL            : 49
OR                   : 40
PARA                 : 15
REAL                 : 30
SE                   : 16 17
SENAO                : 17
SMALLER              : 44
SMALLER_EQUAL        : 45
STRING               : 6 7
TRUE                 : 54
V                    : 6
VAR                  : 18 19 20 21 24 25 26
XOR                  : 42
[                    : 15
]                    : 15
error                : 

Nonterminals, with rules where they appear

LstV                 : 1 2
S                    : 0
callfunc             : 12
ciclo_for            : 11
com_list             : 3 5 15 16 17 17 18 19
command              : 2 4 5
condicao             : 33
e                    : 8 16 17 27 28 34 35 35 36 36 37 37 38 38 40 40 41 41 42 42 43 44 44 45 45 46 46 47 47 48 48 49 49
e_list               : 10 20 28
func                 : 14
if                   : 13
logico               : 39 56
type                 : 24
var_fun              : 22 23
var_fun_list         : 18 23
var_list             : 6 9 26

Parsing method: LALR

state 0

    (0) S' -> . S
    (1) S -> . LstV ;
    (2) LstV -> . LstV ; command
    (3) LstV -> . com_list
    (4) com_list -> . command
    (5) com_list -> . com_list command
    (6) command -> . V STRING ATRIBUICAO var_list
    (7) command -> . ESCREVER STRING ;
    (8) command -> . ESCREVER e
    (9) command -> . ESCREVER var_list
    (10) command -> . ID ATRIBUICAO e_list
    (11) command -> . ciclo_for
    (12) command -> . callfunc ;
    (13) command -> . if
    (14) command -> . func
    (15) ciclo_for -> . PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM
    (20) callfunc -> . VAR ( e_list )
    (21) callfunc -> . VAR ( )
    (16) if -> . SE e ENTAO com_list FIM_SE
    (17) if -> . SE e ENTAO com_list SENAO com_list FIM_SE
    (18) func -> . FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO
    (19) func -> . FUNCAO VAR ( ) com_list FIM_FUNCAO

    V               shift and go to state 5
    ESCREVER        shift and go to state 6
    ID              shift and go to state 7
    PARA            shift and go to state 12
    VAR             shift and go to state 13
    SE              shift and go to state 14
    FUNCAO          shift and go to state 15

    S                              shift and go to state 1
    LstV                           shift and go to state 2
    command                        shift and go to state 3
    com_list                       shift and go to state 4
    ciclo_for                      shift and go to state 8
    callfunc                       shift and go to state 9
    if                             shift and go to state 10
    func                           shift and go to state 11

state 1

    (0) S' -> S .



state 2

    (1) S -> LstV . ;
    (2) LstV -> LstV . ; command

    ;               shift and go to state 16


state 3

    (4) com_list -> command .

    V               reduce using rule 4 (com_list -> command .)
    ESCREVER        reduce using rule 4 (com_list -> command .)
    ID              reduce using rule 4 (com_list -> command .)
    PARA            reduce using rule 4 (com_list -> command .)
    VAR             reduce using rule 4 (com_list -> command .)
    SE              reduce using rule 4 (com_list -> command .)
    FUNCAO          reduce using rule 4 (com_list -> command .)
    ;               reduce using rule 4 (com_list -> command .)
    FIM_SE          reduce using rule 4 (com_list -> command .)
    SENAO           reduce using rule 4 (com_list -> command .)
    FIM_FUNCAO      reduce using rule 4 (com_list -> command .)
    FIM             reduce using rule 4 (com_list -> command .)


state 4

    (3) LstV -> com_list .
    (5) com_list -> com_list . command
    (6) command -> . V STRING ATRIBUICAO var_list
    (7) command -> . ESCREVER STRING ;
    (8) command -> . ESCREVER e
    (9) command -> . ESCREVER var_list
    (10) command -> . ID ATRIBUICAO e_list
    (11) command -> . ciclo_for
    (12) command -> . callfunc ;
    (13) command -> . if
    (14) command -> . func
    (15) ciclo_for -> . PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM
    (20) callfunc -> . VAR ( e_list )
    (21) callfunc -> . VAR ( )
    (16) if -> . SE e ENTAO com_list FIM_SE
    (17) if -> . SE e ENTAO com_list SENAO com_list FIM_SE
    (18) func -> . FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO
    (19) func -> . FUNCAO VAR ( ) com_list FIM_FUNCAO

    ;               reduce using rule 3 (LstV -> com_list .)
    V               shift and go to state 5
    ESCREVER        shift and go to state 6
    ID              shift and go to state 7
    PARA            shift and go to state 12
    VAR             shift and go to state 13
    SE              shift and go to state 14
    FUNCAO          shift and go to state 15

    command                        shift and go to state 17
    ciclo_for                      shift and go to state 8
    callfunc                       shift and go to state 9
    if                             shift and go to state 10
    func                           shift and go to state 11

state 5

    (6) command -> V . STRING ATRIBUICAO var_list

    STRING          shift and go to state 18


state 6

    (7) command -> ESCREVER . STRING ;
    (8) command -> ESCREVER . e
    (9) command -> ESCREVER . var_list
    (29) e -> . ID
    (30) e -> . REAL
    (31) e -> . INTEIRO
    (32) e -> . CARACTER
    (33) e -> . condicao
    (34) e -> . - e
    (35) e -> . e * e
    (36) e -> . e / e
    (37) e -> . e + e
    (38) e -> . e - e
    (39) e -> . logico
    (40) e -> . e OR e
    (41) e -> . e AND e
    (42) e -> . e XOR e
    (43) e -> . ( e )
    (25) var_list -> . VAR
    (26) var_list -> . var_list , VAR
    (44) condicao -> . e SMALLER e
    (45) condicao -> . e SMALLER_EQUAL e
    (46) condicao -> . e BIGGER e
    (47) condicao -> . e BIGGER_EQUAL e
    (48) condicao -> . e EQUAL e
    (49) condicao -> . e NOT_EQUAL e
    (54) logico -> . TRUE
    (55) logico -> . FALSE
    (56) logico -> . NOT logico

    STRING          shift and go to state 19
    ID              shift and go to state 22
    REAL            shift and go to state 23
    INTEIRO         shift and go to state 24
    CARACTER        shift and go to state 25
    -               shift and go to state 27
    (               shift and go to state 29
    VAR             shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    NOT             shift and go to state 33

    e                              shift and go to state 20
    var_list                       shift and go to state 21
    condicao                       shift and go to state 26
    logico                         shift and go to state 28

state 7

    (10) command -> ID . ATRIBUICAO e_list

    ATRIBUICAO      shift and go to state 34


state 8

    (11) command -> ciclo_for .

    V               reduce using rule 11 (command -> ciclo_for .)
    ESCREVER        reduce using rule 11 (command -> ciclo_for .)
    ID              reduce using rule 11 (command -> ciclo_for .)
    PARA            reduce using rule 11 (command -> ciclo_for .)
    VAR             reduce using rule 11 (command -> ciclo_for .)
    SE              reduce using rule 11 (command -> ciclo_for .)
    FUNCAO          reduce using rule 11 (command -> ciclo_for .)
    ;               reduce using rule 11 (command -> ciclo_for .)
    FIM_SE          reduce using rule 11 (command -> ciclo_for .)
    SENAO           reduce using rule 11 (command -> ciclo_for .)
    FIM_FUNCAO      reduce using rule 11 (command -> ciclo_for .)
    FIM             reduce using rule 11 (command -> ciclo_for .)


state 9

    (12) command -> callfunc . ;

    ;               shift and go to state 35


state 10

    (13) command -> if .

    V               reduce using rule 13 (command -> if .)
    ESCREVER        reduce using rule 13 (command -> if .)
    ID              reduce using rule 13 (command -> if .)
    PARA            reduce using rule 13 (command -> if .)
    VAR             reduce using rule 13 (command -> if .)
    SE              reduce using rule 13 (command -> if .)
    FUNCAO          reduce using rule 13 (command -> if .)
    ;               reduce using rule 13 (command -> if .)
    FIM_SE          reduce using rule 13 (command -> if .)
    SENAO           reduce using rule 13 (command -> if .)
    FIM_FUNCAO      reduce using rule 13 (command -> if .)
    FIM             reduce using rule 13 (command -> if .)


state 11

    (14) command -> func .

    V               reduce using rule 14 (command -> func .)
    ESCREVER        reduce using rule 14 (command -> func .)
    ID              reduce using rule 14 (command -> func .)
    PARA            reduce using rule 14 (command -> func .)
    VAR             reduce using rule 14 (command -> func .)
    SE              reduce using rule 14 (command -> func .)
    FUNCAO          reduce using rule 14 (command -> func .)
    ;               reduce using rule 14 (command -> func .)
    FIM_SE          reduce using rule 14 (command -> func .)
    SENAO           reduce using rule 14 (command -> func .)
    FIM_FUNCAO      reduce using rule 14 (command -> func .)
    FIM             reduce using rule 14 (command -> func .)


state 12

    (15) ciclo_for -> PARA . ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM

    ID              shift and go to state 36


state 13

    (20) callfunc -> VAR . ( e_list )
    (21) callfunc -> VAR . ( )

    (               shift and go to state 37


state 14

    (16) if -> SE . e ENTAO com_list FIM_SE
    (17) if -> SE . e ENTAO com_list SENAO com_list FIM_SE
    (29) e -> . ID
    (30) e -> . REAL
    (31) e -> . INTEIRO
    (32) e -> . CARACTER
    (33) e -> . condicao
    (34) e -> . - e
    (35) e -> . e * e
    (36) e -> . e / e
    (37) e -> . e + e
    (38) e -> . e - e
    (39) e -> . logico
    (40) e -> . e OR e
    (41) e -> . e AND e
    (42) e -> . e XOR e
    (43) e -> . ( e )
    (44) condicao -> . e SMALLER e
    (45) condicao -> . e SMALLER_EQUAL e
    (46) condicao -> . e BIGGER e
    (47) condicao -> . e BIGGER_EQUAL e
    (48) condicao -> . e EQUAL e
    (49) condicao -> . e NOT_EQUAL e
    (54) logico -> . TRUE
    (55) logico -> . FALSE
    (56) logico -> . NOT logico

    ID              shift and go to state 22
    REAL            shift and go to state 23
    INTEIRO         shift and go to state 24
    CARACTER        shift and go to state 25
    -               shift and go to state 27
    (               shift and go to state 29
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    NOT             shift and go to state 33

    e                              shift and go to state 38
    condicao                       shift and go to state 26
    logico                         shift and go to state 28

state 15

    (18) func -> FUNCAO . VAR ( var_fun_list ) com_list FIM_FUNCAO
    (19) func -> FUNCAO . VAR ( ) com_list FIM_FUNCAO

    VAR             shift and go to state 39


state 16

    (1) S -> LstV ; .
    (2) LstV -> LstV ; . command
    (6) command -> . V STRING ATRIBUICAO var_list
    (7) command -> . ESCREVER STRING ;
    (8) command -> . ESCREVER e
    (9) command -> . ESCREVER var_list
    (10) command -> . ID ATRIBUICAO e_list
    (11) command -> . ciclo_for
    (12) command -> . callfunc ;
    (13) command -> . if
    (14) command -> . func
    (15) ciclo_for -> . PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM
    (20) callfunc -> . VAR ( e_list )
    (21) callfunc -> . VAR ( )
    (16) if -> . SE e ENTAO com_list FIM_SE
    (17) if -> . SE e ENTAO com_list SENAO com_list FIM_SE
    (18) func -> . FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO
    (19) func -> . FUNCAO VAR ( ) com_list FIM_FUNCAO

    $end            reduce using rule 1 (S -> LstV ; .)
    V               shift and go to state 5
    ESCREVER        shift and go to state 6
    ID              shift and go to state 7
    PARA            shift and go to state 12
    VAR             shift and go to state 13
    SE              shift and go to state 14
    FUNCAO          shift and go to state 15

    command                        shift and go to state 40
    ciclo_for                      shift and go to state 8
    callfunc                       shift and go to state 9
    if                             shift and go to state 10
    func                           shift and go to state 11

state 17

    (5) com_list -> com_list command .

    V               reduce using rule 5 (com_list -> com_list command .)
    ESCREVER        reduce using rule 5 (com_list -> com_list command .)
    ID              reduce using rule 5 (com_list -> com_list command .)
    PARA            reduce using rule 5 (com_list -> com_list command .)
    VAR             reduce using rule 5 (com_list -> com_list command .)
    SE              reduce using rule 5 (com_list -> com_list command .)
    FUNCAO          reduce using rule 5 (com_list -> com_list command .)
    ;               reduce using rule 5 (com_list -> com_list command .)
    FIM_SE          reduce using rule 5 (com_list -> com_list command .)
    SENAO           reduce using rule 5 (com_list -> com_list command .)
    FIM_FUNCAO      reduce using rule 5 (com_list -> com_list command .)
    FIM             reduce using rule 5 (com_list -> com_list command .)


state 18

    (6) command -> V STRING . ATRIBUICAO var_list

    ATRIBUICAO      shift and go to state 41


state 19

    (7) command -> ESCREVER STRING . ;

    ;               shift and go to state 42


state 20

    (8) command -> ESCREVER e .
    (35) e -> e . * e
    (36) e -> e . / e
    (37) e -> e . + e
    (38) e -> e . - e
    (40) e -> e . OR e
    (41) e -> e . AND e
    (42) e -> e . XOR e
    (44) condicao -> e . SMALLER e
    (45) condicao -> e . SMALLER_EQUAL e
    (46) condicao -> e . BIGGER e
    (47) condicao -> e . BIGGER_EQUAL e
    (48) condicao -> e . EQUAL e
    (49) condicao -> e . NOT_EQUAL e

    V               reduce using rule 8 (command -> ESCREVER e .)
    ESCREVER        reduce using rule 8 (command -> ESCREVER e .)
    ID              reduce using rule 8 (command -> ESCREVER e .)
    PARA            reduce using rule 8 (command -> ESCREVER e .)
    VAR             reduce using rule 8 (command -> ESCREVER e .)
    SE              reduce using rule 8 (command -> ESCREVER e .)
    FUNCAO          reduce using rule 8 (command -> ESCREVER e .)
    ;               reduce using rule 8 (command -> ESCREVER e .)
    FIM_SE          reduce using rule 8 (command -> ESCREVER e .)
    SENAO           reduce using rule 8 (command -> ESCREVER e .)
    FIM_FUNCAO      reduce using rule 8 (command -> ESCREVER e .)
    FIM             reduce using rule 8 (command -> ESCREVER e .)
    *               shift and go to state 43
    /               shift and go to state 44
    +               shift and go to state 45
    -               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    XOR             shift and go to state 49
    SMALLER         shift and go to state 50
    SMALLER_EQUAL   shift and go to state 51
    BIGGER          shift and go to state 52
    BIGGER_EQUAL    shift and go to state 53
    EQUAL           shift and go to state 54
    NOT_EQUAL       shift and go to state 55


state 21

    (9) command -> ESCREVER var_list .
    (26) var_list -> var_list . , VAR

    V               reduce using rule 9 (command -> ESCREVER var_list .)
    ESCREVER        reduce using rule 9 (command -> ESCREVER var_list .)
    ID              reduce using rule 9 (command -> ESCREVER var_list .)
    PARA            reduce using rule 9 (command -> ESCREVER var_list .)
    VAR             reduce using rule 9 (command -> ESCREVER var_list .)
    SE              reduce using rule 9 (command -> ESCREVER var_list .)
    FUNCAO          reduce using rule 9 (command -> ESCREVER var_list .)
    ;               reduce using rule 9 (command -> ESCREVER var_list .)
    FIM_SE          reduce using rule 9 (command -> ESCREVER var_list .)
    SENAO           reduce using rule 9 (command -> ESCREVER var_list .)
    FIM_FUNCAO      reduce using rule 9 (command -> ESCREVER var_list .)
    FIM             reduce using rule 9 (command -> ESCREVER var_list .)
    ,               shift and go to state 56


state 22

    (29) e -> ID .

    *               reduce using rule 29 (e -> ID .)
    /               reduce using rule 29 (e -> ID .)
    +               reduce using rule 29 (e -> ID .)
    -               reduce using rule 29 (e -> ID .)
    OR              reduce using rule 29 (e -> ID .)
    AND             reduce using rule 29 (e -> ID .)
    XOR             reduce using rule 29 (e -> ID .)
    SMALLER         reduce using rule 29 (e -> ID .)
    SMALLER_EQUAL   reduce using rule 29 (e -> ID .)
    BIGGER          reduce using rule 29 (e -> ID .)
    BIGGER_EQUAL    reduce using rule 29 (e -> ID .)
    EQUAL           reduce using rule 29 (e -> ID .)
    NOT_EQUAL       reduce using rule 29 (e -> ID .)
    V               reduce using rule 29 (e -> ID .)
    ESCREVER        reduce using rule 29 (e -> ID .)
    ID              reduce using rule 29 (e -> ID .)
    PARA            reduce using rule 29 (e -> ID .)
    VAR             reduce using rule 29 (e -> ID .)
    SE              reduce using rule 29 (e -> ID .)
    FUNCAO          reduce using rule 29 (e -> ID .)
    ;               reduce using rule 29 (e -> ID .)
    FIM_SE          reduce using rule 29 (e -> ID .)
    SENAO           reduce using rule 29 (e -> ID .)
    FIM_FUNCAO      reduce using rule 29 (e -> ID .)
    FIM             reduce using rule 29 (e -> ID .)
    ENTAO           reduce using rule 29 (e -> ID .)
    )               reduce using rule 29 (e -> ID .)
    ,               reduce using rule 29 (e -> ID .)


state 23

    (30) e -> REAL .

    *               reduce using rule 30 (e -> REAL .)
    /               reduce using rule 30 (e -> REAL .)
    +               reduce using rule 30 (e -> REAL .)
    -               reduce using rule 30 (e -> REAL .)
    OR              reduce using rule 30 (e -> REAL .)
    AND             reduce using rule 30 (e -> REAL .)
    XOR             reduce using rule 30 (e -> REAL .)
    SMALLER         reduce using rule 30 (e -> REAL .)
    SMALLER_EQUAL   reduce using rule 30 (e -> REAL .)
    BIGGER          reduce using rule 30 (e -> REAL .)
    BIGGER_EQUAL    reduce using rule 30 (e -> REAL .)
    EQUAL           reduce using rule 30 (e -> REAL .)
    NOT_EQUAL       reduce using rule 30 (e -> REAL .)
    V               reduce using rule 30 (e -> REAL .)
    ESCREVER        reduce using rule 30 (e -> REAL .)
    ID              reduce using rule 30 (e -> REAL .)
    PARA            reduce using rule 30 (e -> REAL .)
    VAR             reduce using rule 30 (e -> REAL .)
    SE              reduce using rule 30 (e -> REAL .)
    FUNCAO          reduce using rule 30 (e -> REAL .)
    ;               reduce using rule 30 (e -> REAL .)
    FIM_SE          reduce using rule 30 (e -> REAL .)
    SENAO           reduce using rule 30 (e -> REAL .)
    FIM_FUNCAO      reduce using rule 30 (e -> REAL .)
    FIM             reduce using rule 30 (e -> REAL .)
    ENTAO           reduce using rule 30 (e -> REAL .)
    )               reduce using rule 30 (e -> REAL .)
    ,               reduce using rule 30 (e -> REAL .)


state 24

    (31) e -> INTEIRO .

    *               reduce using rule 31 (e -> INTEIRO .)
    /               reduce using rule 31 (e -> INTEIRO .)
    +               reduce using rule 31 (e -> INTEIRO .)
    -               reduce using rule 31 (e -> INTEIRO .)
    OR              reduce using rule 31 (e -> INTEIRO .)
    AND             reduce using rule 31 (e -> INTEIRO .)
    XOR             reduce using rule 31 (e -> INTEIRO .)
    SMALLER         reduce using rule 31 (e -> INTEIRO .)
    SMALLER_EQUAL   reduce using rule 31 (e -> INTEIRO .)
    BIGGER          reduce using rule 31 (e -> INTEIRO .)
    BIGGER_EQUAL    reduce using rule 31 (e -> INTEIRO .)
    EQUAL           reduce using rule 31 (e -> INTEIRO .)
    NOT_EQUAL       reduce using rule 31 (e -> INTEIRO .)
    V               reduce using rule 31 (e -> INTEIRO .)
    ESCREVER        reduce using rule 31 (e -> INTEIRO .)
    ID              reduce using rule 31 (e -> INTEIRO .)
    PARA            reduce using rule 31 (e -> INTEIRO .)
    VAR             reduce using rule 31 (e -> INTEIRO .)
    SE              reduce using rule 31 (e -> INTEIRO .)
    FUNCAO          reduce using rule 31 (e -> INTEIRO .)
    ;               reduce using rule 31 (e -> INTEIRO .)
    FIM_SE          reduce using rule 31 (e -> INTEIRO .)
    SENAO           reduce using rule 31 (e -> INTEIRO .)
    FIM_FUNCAO      reduce using rule 31 (e -> INTEIRO .)
    FIM             reduce using rule 31 (e -> INTEIRO .)
    ENTAO           reduce using rule 31 (e -> INTEIRO .)
    )               reduce using rule 31 (e -> INTEIRO .)
    ,               reduce using rule 31 (e -> INTEIRO .)


state 25

    (32) e -> CARACTER .

    *               reduce using rule 32 (e -> CARACTER .)
    /               reduce using rule 32 (e -> CARACTER .)
    +               reduce using rule 32 (e -> CARACTER .)
    -               reduce using rule 32 (e -> CARACTER .)
    OR              reduce using rule 32 (e -> CARACTER .)
    AND             reduce using rule 32 (e -> CARACTER .)
    XOR             reduce using rule 32 (e -> CARACTER .)
    SMALLER         reduce using rule 32 (e -> CARACTER .)
    SMALLER_EQUAL   reduce using rule 32 (e -> CARACTER .)
    BIGGER          reduce using rule 32 (e -> CARACTER .)
    BIGGER_EQUAL    reduce using rule 32 (e -> CARACTER .)
    EQUAL           reduce using rule 32 (e -> CARACTER .)
    NOT_EQUAL       reduce using rule 32 (e -> CARACTER .)
    V               reduce using rule 32 (e -> CARACTER .)
    ESCREVER        reduce using rule 32 (e -> CARACTER .)
    ID              reduce using rule 32 (e -> CARACTER .)
    PARA            reduce using rule 32 (e -> CARACTER .)
    VAR             reduce using rule 32 (e -> CARACTER .)
    SE              reduce using rule 32 (e -> CARACTER .)
    FUNCAO          reduce using rule 32 (e -> CARACTER .)
    ;               reduce using rule 32 (e -> CARACTER .)
    FIM_SE          reduce using rule 32 (e -> CARACTER .)
    SENAO           reduce using rule 32 (e -> CARACTER .)
    FIM_FUNCAO      reduce using rule 32 (e -> CARACTER .)
    FIM             reduce using rule 32 (e -> CARACTER .)
    ENTAO           reduce using rule 32 (e -> CARACTER .)
    )               reduce using rule 32 (e -> CARACTER .)
    ,               reduce using rule 32 (e -> CARACTER .)


state 26

    (33) e -> condicao .

    *               reduce using rule 33 (e -> condicao .)
    /               reduce using rule 33 (e -> condicao .)
    +               reduce using rule 33 (e -> condicao .)
    -               reduce using rule 33 (e -> condicao .)
    OR              reduce using rule 33 (e -> condicao .)
    AND             reduce using rule 33 (e -> condicao .)
    XOR             reduce using rule 33 (e -> condicao .)
    SMALLER         reduce using rule 33 (e -> condicao .)
    SMALLER_EQUAL   reduce using rule 33 (e -> condicao .)
    BIGGER          reduce using rule 33 (e -> condicao .)
    BIGGER_EQUAL    reduce using rule 33 (e -> condicao .)
    EQUAL           reduce using rule 33 (e -> condicao .)
    NOT_EQUAL       reduce using rule 33 (e -> condicao .)
    V               reduce using rule 33 (e -> condicao .)
    ESCREVER        reduce using rule 33 (e -> condicao .)
    ID              reduce using rule 33 (e -> condicao .)
    PARA            reduce using rule 33 (e -> condicao .)
    VAR             reduce using rule 33 (e -> condicao .)
    SE              reduce using rule 33 (e -> condicao .)
    FUNCAO          reduce using rule 33 (e -> condicao .)
    ;               reduce using rule 33 (e -> condicao .)
    FIM_SE          reduce using rule 33 (e -> condicao .)
    SENAO           reduce using rule 33 (e -> condicao .)
    FIM_FUNCAO      reduce using rule 33 (e -> condicao .)
    FIM             reduce using rule 33 (e -> condicao .)
    ENTAO           reduce using rule 33 (e -> condicao .)
    )               reduce using rule 33 (e -> condicao .)
    ,               reduce using rule 33 (e -> condicao .)


state 27

    (34) e -> - . e
    (29) e -> . ID
    (30) e -> . REAL
    (31) e -> . INTEIRO
    (32) e -> . CARACTER
    (33) e -> . condicao
    (34) e -> . - e
    (35) e -> . e * e
    (36) e -> . e / e
    (37) e -> . e + e
    (38) e -> . e - e
    (39) e -> . logico
    (40) e -> . e OR e
    (41) e -> . e AND e
    (42) e -> . e XOR e
    (43) e -> . ( e )
    (44) condicao -> . e SMALLER e
    (45) condicao -> . e SMALLER_EQUAL e
    (46) condicao -> . e BIGGER e
    (47) condicao -> . e BIGGER_EQUAL e
    (48) condicao -> . e EQUAL e
    (49) condicao -> . e NOT_EQUAL e
    (54) logico -> . TRUE
    (55) logico -> . FALSE
    (56) logico -> . NOT logico

    ID              shift and go to state 22
    REAL            shift and go to state 23
    INTEIRO         shift and go to state 24
    CARACTER        shift and go to state 25
    -               shift and go to state 27
    (               shift and go to state 29
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    NOT             shift and go to state 33

    e                              shift and go to state 57
    condicao                       shift and go to state 26
    logico                         shift and go to state 28

state 28

    (39) e -> logico .

    *               reduce using rule 39 (e -> logico .)
    /               reduce using rule 39 (e -> logico .)
    +               reduce using rule 39 (e -> logico .)
    -               reduce using rule 39 (e -> logico .)
    OR              reduce using rule 39 (e -> logico .)
    AND             reduce using rule 39 (e -> logico .)
    XOR             reduce using rule 39 (e -> logico .)
    SMALLER         reduce using rule 39 (e -> logico .)
    SMALLER_EQUAL   reduce using rule 39 (e -> logico .)
    BIGGER          reduce using rule 39 (e -> logico .)
    BIGGER_EQUAL    reduce using rule 39 (e -> logico .)
    EQUAL           reduce using rule 39 (e -> logico .)
    NOT_EQUAL       reduce using rule 39 (e -> logico .)
    V               reduce using rule 39 (e -> logico .)
    ESCREVER        reduce using rule 39 (e -> logico .)
    ID              reduce using rule 39 (e -> logico .)
    PARA            reduce using rule 39 (e -> logico .)
    VAR             reduce using rule 39 (e -> logico .)
    SE              reduce using rule 39 (e -> logico .)
    FUNCAO          reduce using rule 39 (e -> logico .)
    ;               reduce using rule 39 (e -> logico .)
    FIM_SE          reduce using rule 39 (e -> logico .)
    SENAO           reduce using rule 39 (e -> logico .)
    FIM_FUNCAO      reduce using rule 39 (e -> logico .)
    FIM             reduce using rule 39 (e -> logico .)
    ENTAO           reduce using rule 39 (e -> logico .)
    )               reduce using rule 39 (e -> logico .)
    ,               reduce using rule 39 (e -> logico .)


state 29

    (43) e -> ( . e )
    (29) e -> . ID
    (30) e -> . REAL
    (31) e -> . INTEIRO
    (32) e -> . CARACTER
    (33) e -> . condicao
    (34) e -> . - e
    (35) e -> . e * e
    (36) e -> . e / e
    (37) e -> . e + e
    (38) e -> . e - e
    (39) e -> . logico
    (40) e -> . e OR e
    (41) e -> . e AND e
    (42) e -> . e XOR e
    (43) e -> . ( e )
    (44) condicao -> . e SMALLER e
    (45) condicao -> . e SMALLER_EQUAL e
    (46) condicao -> . e BIGGER e
    (47) condicao -> . e BIGGER_EQUAL e
    (48) condicao -> . e EQUAL e
    (49) condicao -> . e NOT_EQUAL e
    (54) logico -> . TRUE
    (55) logico -> . FALSE
    (56) logico -> . NOT logico

    ID              shift and go to state 22
    REAL            shift and go to state 23
    INTEIRO         shift and go to state 24
    CARACTER        shift and go to state 25
    -               shift and go to state 27
    (               shift and go to state 29
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    NOT             shift and go to state 33

    e                              shift and go to state 58
    condicao                       shift and go to state 26
    logico                         shift and go to state 28

state 30

    (25) var_list -> VAR .

    ,               reduce using rule 25 (var_list -> VAR .)
    V               reduce using rule 25 (var_list -> VAR .)
    ESCREVER        reduce using rule 25 (var_list -> VAR .)
    ID              reduce using rule 25 (var_list -> VAR .)
    PARA            reduce using rule 25 (var_list -> VAR .)
    VAR             reduce using rule 25 (var_list -> VAR .)
    SE              reduce using rule 25 (var_list -> VAR .)
    FUNCAO          reduce using rule 25 (var_list -> VAR .)
    ;               reduce using rule 25 (var_list -> VAR .)
    FIM_SE          reduce using rule 25 (var_list -> VAR .)
    SENAO           reduce using rule 25 (var_list -> VAR .)
    FIM_FUNCAO      reduce using rule 25 (var_list -> VAR .)
    FIM             reduce using rule 25 (var_list -> VAR .)


state 31

    (54) logico -> TRUE .

    *               reduce using rule 54 (logico -> TRUE .)
    /               reduce using rule 54 (logico -> TRUE .)
    +               reduce using rule 54 (logico -> TRUE .)
    -               reduce using rule 54 (logico -> TRUE .)
    OR              reduce using rule 54 (logico -> TRUE .)
    AND             reduce using rule 54 (logico -> TRUE .)
    XOR             reduce using rule 54 (logico -> TRUE .)
    SMALLER         reduce using rule 54 (logico -> TRUE .)
    SMALLER_EQUAL   reduce using rule 54 (logico -> TRUE .)
    BIGGER          reduce using rule 54 (logico -> TRUE .)
    BIGGER_EQUAL    reduce using rule 54 (logico -> TRUE .)
    EQUAL           reduce using rule 54 (logico -> TRUE .)
    NOT_EQUAL       reduce using rule 54 (logico -> TRUE .)
    V               reduce using rule 54 (logico -> TRUE .)
    ESCREVER        reduce using rule 54 (logico -> TRUE .)
    ID              reduce using rule 54 (logico -> TRUE .)
    PARA            reduce using rule 54 (logico -> TRUE .)
    VAR             reduce using rule 54 (logico -> TRUE .)
    SE              reduce using rule 54 (logico -> TRUE .)
    FUNCAO          reduce using rule 54 (logico -> TRUE .)
    ;               reduce using rule 54 (logico -> TRUE .)
    FIM_SE          reduce using rule 54 (logico -> TRUE .)
    SENAO           reduce using rule 54 (logico -> TRUE .)
    FIM_FUNCAO      reduce using rule 54 (logico -> TRUE .)
    FIM             reduce using rule 54 (logico -> TRUE .)
    ENTAO           reduce using rule 54 (logico -> TRUE .)
    )               reduce using rule 54 (logico -> TRUE .)
    ,               reduce using rule 54 (logico -> TRUE .)


state 32

    (55) logico -> FALSE .

    *               reduce using rule 55 (logico -> FALSE .)
    /               reduce using rule 55 (logico -> FALSE .)
    +               reduce using rule 55 (logico -> FALSE .)
    -               reduce using rule 55 (logico -> FALSE .)
    OR              reduce using rule 55 (logico -> FALSE .)
    AND             reduce using rule 55 (logico -> FALSE .)
    XOR             reduce using rule 55 (logico -> FALSE .)
    SMALLER         reduce using rule 55 (logico -> FALSE .)
    SMALLER_EQUAL   reduce using rule 55 (logico -> FALSE .)
    BIGGER          reduce using rule 55 (logico -> FALSE .)
    BIGGER_EQUAL    reduce using rule 55 (logico -> FALSE .)
    EQUAL           reduce using rule 55 (logico -> FALSE .)
    NOT_EQUAL       reduce using rule 55 (logico -> FALSE .)
    V               reduce using rule 55 (logico -> FALSE .)
    ESCREVER        reduce using rule 55 (logico -> FALSE .)
    ID              reduce using rule 55 (logico -> FALSE .)
    PARA            reduce using rule 55 (logico -> FALSE .)
    VAR             reduce using rule 55 (logico -> FALSE .)
    SE              reduce using rule 55 (logico -> FALSE .)
    FUNCAO          reduce using rule 55 (logico -> FALSE .)
    ;               reduce using rule 55 (logico -> FALSE .)
    FIM_SE          reduce using rule 55 (logico -> FALSE .)
    SENAO           reduce using rule 55 (logico -> FALSE .)
    FIM_FUNCAO      reduce using rule 55 (logico -> FALSE .)
    FIM             reduce using rule 55 (logico -> FALSE .)
    ENTAO           reduce using rule 55 (logico -> FALSE .)
    )               reduce using rule 55 (logico -> FALSE .)
    ,               reduce using rule 55 (logico -> FALSE .)


state 33

    (56) logico -> NOT . logico
    (54) logico -> . TRUE
    (55) logico -> . FALSE
    (56) logico -> . NOT logico

    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    NOT             shift and go to state 33

    logico                         shift and go to state 59

state 34

    (10) command -> ID ATRIBUICAO . e_list
    (27) e_list -> . e
    (28) e_list -> . e_list , e
    (29) e -> . ID
    (30) e -> . REAL
    (31) e -> . INTEIRO
    (32) e -> . CARACTER
    (33) e -> . condicao
    (34) e -> . - e
    (35) e -> . e * e
    (36) e -> . e / e
    (37) e -> . e + e
    (38) e -> . e - e
    (39) e -> . logico
    (40) e -> . e OR e
    (41) e -> . e AND e
    (42) e -> . e XOR e
    (43) e -> . ( e )
    (44) condicao -> . e SMALLER e
    (45) condicao -> . e SMALLER_EQUAL e
    (46) condicao -> . e BIGGER e
    (47) condicao -> . e BIGGER_EQUAL e
    (48) condicao -> . e EQUAL e
    (49) condicao -> . e NOT_EQUAL e
    (54) logico -> . TRUE
    (55) logico -> . FALSE
    (56) logico -> . NOT logico

    ID              shift and go to state 22
    REAL            shift and go to state 23
    INTEIRO         shift and go to state 24
    CARACTER        shift and go to state 25
    -               shift and go to state 27
    (               shift and go to state 29
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    NOT             shift and go to state 33

    e_list                         shift and go to state 60
    e                              shift and go to state 61
    condicao                       shift and go to state 26
    logico                         shift and go to state 28

state 35

    (12) command -> callfunc ; .

    V               reduce using rule 12 (command -> callfunc ; .)
    ESCREVER        reduce using rule 12 (command -> callfunc ; .)
    ID              reduce using rule 12 (command -> callfunc ; .)
    PARA            reduce using rule 12 (command -> callfunc ; .)
    VAR             reduce using rule 12 (command -> callfunc ; .)
    SE              reduce using rule 12 (command -> callfunc ; .)
    FUNCAO          reduce using rule 12 (command -> callfunc ; .)
    ;               reduce using rule 12 (command -> callfunc ; .)
    FIM_SE          reduce using rule 12 (command -> callfunc ; .)
    SENAO           reduce using rule 12 (command -> callfunc ; .)
    FIM_FUNCAO      reduce using rule 12 (command -> callfunc ; .)
    FIM             reduce using rule 12 (command -> callfunc ; .)


state 36

    (15) ciclo_for -> PARA ID . EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM

    EM              shift and go to state 62


state 37

    (20) callfunc -> VAR ( . e_list )
    (21) callfunc -> VAR ( . )
    (27) e_list -> . e
    (28) e_list -> . e_list , e
    (29) e -> . ID
    (30) e -> . REAL
    (31) e -> . INTEIRO
    (32) e -> . CARACTER
    (33) e -> . condicao
    (34) e -> . - e
    (35) e -> . e * e
    (36) e -> . e / e
    (37) e -> . e + e
    (38) e -> . e - e
    (39) e -> . logico
    (40) e -> . e OR e
    (41) e -> . e AND e
    (42) e -> . e XOR e
    (43) e -> . ( e )
    (44) condicao -> . e SMALLER e
    (45) condicao -> . e SMALLER_EQUAL e
    (46) condicao -> . e BIGGER e
    (47) condicao -> . e BIGGER_EQUAL e
    (48) condicao -> . e EQUAL e
    (49) condicao -> . e NOT_EQUAL e
    (54) logico -> . TRUE
    (55) logico -> . FALSE
    (56) logico -> . NOT logico

    )               shift and go to state 64
    ID              shift and go to state 22
    REAL            shift and go to state 23
    INTEIRO         shift and go to state 24
    CARACTER        shift and go to state 25
    -               shift and go to state 27
    (               shift and go to state 29
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    NOT             shift and go to state 33

    e_list                         shift and go to state 63
    e                              shift and go to state 61
    condicao                       shift and go to state 26
    logico                         shift and go to state 28

state 38

    (16) if -> SE e . ENTAO com_list FIM_SE
    (17) if -> SE e . ENTAO com_list SENAO com_list FIM_SE
    (35) e -> e . * e
    (36) e -> e . / e
    (37) e -> e . + e
    (38) e -> e . - e
    (40) e -> e . OR e
    (41) e -> e . AND e
    (42) e -> e . XOR e
    (44) condicao -> e . SMALLER e
    (45) condicao -> e . SMALLER_EQUAL e
    (46) condicao -> e . BIGGER e
    (47) condicao -> e . BIGGER_EQUAL e
    (48) condicao -> e . EQUAL e
    (49) condicao -> e . NOT_EQUAL e

    ENTAO           shift and go to state 65
    *               shift and go to state 43
    /               shift and go to state 44
    +               shift and go to state 45
    -               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    XOR             shift and go to state 49
    SMALLER         shift and go to state 50
    SMALLER_EQUAL   shift and go to state 51
    BIGGER          shift and go to state 52
    BIGGER_EQUAL    shift and go to state 53
    EQUAL           shift and go to state 54
    NOT_EQUAL       shift and go to state 55


state 39

    (18) func -> FUNCAO VAR . ( var_fun_list ) com_list FIM_FUNCAO
    (19) func -> FUNCAO VAR . ( ) com_list FIM_FUNCAO

    (               shift and go to state 66


state 40

    (2) LstV -> LstV ; command .

    ;               reduce using rule 2 (LstV -> LstV ; command .)


state 41

    (6) command -> V STRING ATRIBUICAO . var_list
    (25) var_list -> . VAR
    (26) var_list -> . var_list , VAR

    VAR             shift and go to state 30

    var_list                       shift and go to state 67

state 42

    (7) command -> ESCREVER STRING ; .

    V               reduce using rule 7 (command -> ESCREVER STRING ; .)
    ESCREVER        reduce using rule 7 (command -> ESCREVER STRING ; .)
    ID              reduce using rule 7 (command -> ESCREVER STRING ; .)
    PARA            reduce using rule 7 (command -> ESCREVER STRING ; .)
    VAR             reduce using rule 7 (command -> ESCREVER STRING ; .)
    SE              reduce using rule 7 (command -> ESCREVER STRING ; .)
    FUNCAO          reduce using rule 7 (command -> ESCREVER STRING ; .)
    ;               reduce using rule 7 (command -> ESCREVER STRING ; .)
    FIM_SE          reduce using rule 7 (command -> ESCREVER STRING ; .)
    SENAO           reduce using rule 7 (command -> ESCREVER STRING ; .)
    FIM_FUNCAO      reduce using rule 7 (command -> ESCREVER STRING ; .)
    FIM             reduce using rule 7 (command -> ESCREVER STRING ; .)


state 43

    (35) e -> e * . e
    (29) e -> . ID
    (30) e -> . REAL
    (31) e -> . INTEIRO
    (32) e -> . CARACTER
    (33) e -> . condicao
    (34) e -> . - e
    (35) e -> . e * e
    (36) e -> . e / e
    (37) e -> . e + e
    (38) e -> . e - e
    (39) e -> . logico
    (40) e -> . e OR e
    (41) e -> . e AND e
    (42) e -> . e XOR e
    (43) e -> . ( e )
    (44) condicao -> . e SMALLER e
    (45) condicao -> . e SMALLER_EQUAL e
    (46) condicao -> . e BIGGER e
    (47) condicao -> . e BIGGER_EQUAL e
    (48) condicao -> . e EQUAL e
    (49) condicao -> . e NOT_EQUAL e
    (54) logico -> . TRUE
    (55) logico -> . FALSE
    (56) logico -> . NOT logico

    ID              shift and go to state 22
    REAL            shift and go to state 23
    INTEIRO         shift and go to state 24
    CARACTER        shift and go to state 25
    -               shift and go to state 27
    (               shift and go to state 29
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    NOT             shift and go to state 33

    e                              shift and go to state 68
    condicao                       shift and go to state 26
    logico                         shift and go to state 28

state 44

    (36) e -> e / . e
    (29) e -> . ID
    (30) e -> . REAL
    (31) e -> . INTEIRO
    (32) e -> . CARACTER
    (33) e -> . condicao
    (34) e -> . - e
    (35) e -> . e * e
    (36) e -> . e / e
    (37) e -> . e + e
    (38) e -> . e - e
    (39) e -> . logico
    (40) e -> . e OR e
    (41) e -> . e AND e
    (42) e -> . e XOR e
    (43) e -> . ( e )
    (44) condicao -> . e SMALLER e
    (45) condicao -> . e SMALLER_EQUAL e
    (46) condicao -> . e BIGGER e
    (47) condicao -> . e BIGGER_EQUAL e
    (48) condicao -> . e EQUAL e
    (49) condicao -> . e NOT_EQUAL e
    (54) logico -> . TRUE
    (55) logico -> . FALSE
    (56) logico -> . NOT logico

    ID              shift and go to state 22
    REAL            shift and go to state 23
    INTEIRO         shift and go to state 24
    CARACTER        shift and go to state 25
    -               shift and go to state 27
    (               shift and go to state 29
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    NOT             shift and go to state 33

    e                              shift and go to state 69
    condicao                       shift and go to state 26
    logico                         shift and go to state 28

state 45

    (37) e -> e + . e
    (29) e -> . ID
    (30) e -> . REAL
    (31) e -> . INTEIRO
    (32) e -> . CARACTER
    (33) e -> . condicao
    (34) e -> . - e
    (35) e -> . e * e
    (36) e -> . e / e
    (37) e -> . e + e
    (38) e -> . e - e
    (39) e -> . logico
    (40) e -> . e OR e
    (41) e -> . e AND e
    (42) e -> . e XOR e
    (43) e -> . ( e )
    (44) condicao -> . e SMALLER e
    (45) condicao -> . e SMALLER_EQUAL e
    (46) condicao -> . e BIGGER e
    (47) condicao -> . e BIGGER_EQUAL e
    (48) condicao -> . e EQUAL e
    (49) condicao -> . e NOT_EQUAL e
    (54) logico -> . TRUE
    (55) logico -> . FALSE
    (56) logico -> . NOT logico

    ID              shift and go to state 22
    REAL            shift and go to state 23
    INTEIRO         shift and go to state 24
    CARACTER        shift and go to state 25
    -               shift and go to state 27
    (               shift and go to state 29
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    NOT             shift and go to state 33

    e                              shift and go to state 70
    condicao                       shift and go to state 26
    logico                         shift and go to state 28

state 46

    (38) e -> e - . e
    (29) e -> . ID
    (30) e -> . REAL
    (31) e -> . INTEIRO
    (32) e -> . CARACTER
    (33) e -> . condicao
    (34) e -> . - e
    (35) e -> . e * e
    (36) e -> . e / e
    (37) e -> . e + e
    (38) e -> . e - e
    (39) e -> . logico
    (40) e -> . e OR e
    (41) e -> . e AND e
    (42) e -> . e XOR e
    (43) e -> . ( e )
    (44) condicao -> . e SMALLER e
    (45) condicao -> . e SMALLER_EQUAL e
    (46) condicao -> . e BIGGER e
    (47) condicao -> . e BIGGER_EQUAL e
    (48) condicao -> . e EQUAL e
    (49) condicao -> . e NOT_EQUAL e
    (54) logico -> . TRUE
    (55) logico -> . FALSE
    (56) logico -> . NOT logico

    ID              shift and go to state 22
    REAL            shift and go to state 23
    INTEIRO         shift and go to state 24
    CARACTER        shift and go to state 25
    -               shift and go to state 27
    (               shift and go to state 29
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    NOT             shift and go to state 33

    e                              shift and go to state 71
    condicao                       shift and go to state 26
    logico                         shift and go to state 28

state 47

    (40) e -> e OR . e
    (29) e -> . ID
    (30) e -> . REAL
    (31) e -> . INTEIRO
    (32) e -> . CARACTER
    (33) e -> . condicao
    (34) e -> . - e
    (35) e -> . e * e
    (36) e -> . e / e
    (37) e -> . e + e
    (38) e -> . e - e
    (39) e -> . logico
    (40) e -> . e OR e
    (41) e -> . e AND e
    (42) e -> . e XOR e
    (43) e -> . ( e )
    (44) condicao -> . e SMALLER e
    (45) condicao -> . e SMALLER_EQUAL e
    (46) condicao -> . e BIGGER e
    (47) condicao -> . e BIGGER_EQUAL e
    (48) condicao -> . e EQUAL e
    (49) condicao -> . e NOT_EQUAL e
    (54) logico -> . TRUE
    (55) logico -> . FALSE
    (56) logico -> . NOT logico

    ID              shift and go to state 22
    REAL            shift and go to state 23
    INTEIRO         shift and go to state 24
    CARACTER        shift and go to state 25
    -               shift and go to state 27
    (               shift and go to state 29
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    NOT             shift and go to state 33

    e                              shift and go to state 72
    condicao                       shift and go to state 26
    logico                         shift and go to state 28

state 48

    (41) e -> e AND . e
    (29) e -> . ID
    (30) e -> . REAL
    (31) e -> . INTEIRO
    (32) e -> . CARACTER
    (33) e -> . condicao
    (34) e -> . - e
    (35) e -> . e * e
    (36) e -> . e / e
    (37) e -> . e + e
    (38) e -> . e - e
    (39) e -> . logico
    (40) e -> . e OR e
    (41) e -> . e AND e
    (42) e -> . e XOR e
    (43) e -> . ( e )
    (44) condicao -> . e SMALLER e
    (45) condicao -> . e SMALLER_EQUAL e
    (46) condicao -> . e BIGGER e
    (47) condicao -> . e BIGGER_EQUAL e
    (48) condicao -> . e EQUAL e
    (49) condicao -> . e NOT_EQUAL e
    (54) logico -> . TRUE
    (55) logico -> . FALSE
    (56) logico -> . NOT logico

    ID              shift and go to state 22
    REAL            shift and go to state 23
    INTEIRO         shift and go to state 24
    CARACTER        shift and go to state 25
    -               shift and go to state 27
    (               shift and go to state 29
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    NOT             shift and go to state 33

    e                              shift and go to state 73
    condicao                       shift and go to state 26
    logico                         shift and go to state 28

state 49

    (42) e -> e XOR . e
    (29) e -> . ID
    (30) e -> . REAL
    (31) e -> . INTEIRO
    (32) e -> . CARACTER
    (33) e -> . condicao
    (34) e -> . - e
    (35) e -> . e * e
    (36) e -> . e / e
    (37) e -> . e + e
    (38) e -> . e - e
    (39) e -> . logico
    (40) e -> . e OR e
    (41) e -> . e AND e
    (42) e -> . e XOR e
    (43) e -> . ( e )
    (44) condicao -> . e SMALLER e
    (45) condicao -> . e SMALLER_EQUAL e
    (46) condicao -> . e BIGGER e
    (47) condicao -> . e BIGGER_EQUAL e
    (48) condicao -> . e EQUAL e
    (49) condicao -> . e NOT_EQUAL e
    (54) logico -> . TRUE
    (55) logico -> . FALSE
    (56) logico -> . NOT logico

    ID              shift and go to state 22
    REAL            shift and go to state 23
    INTEIRO         shift and go to state 24
    CARACTER        shift and go to state 25
    -               shift and go to state 27
    (               shift and go to state 29
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    NOT             shift and go to state 33

    e                              shift and go to state 74
    condicao                       shift and go to state 26
    logico                         shift and go to state 28

state 50

    (44) condicao -> e SMALLER . e
    (29) e -> . ID
    (30) e -> . REAL
    (31) e -> . INTEIRO
    (32) e -> . CARACTER
    (33) e -> . condicao
    (34) e -> . - e
    (35) e -> . e * e
    (36) e -> . e / e
    (37) e -> . e + e
    (38) e -> . e - e
    (39) e -> . logico
    (40) e -> . e OR e
    (41) e -> . e AND e
    (42) e -> . e XOR e
    (43) e -> . ( e )
    (44) condicao -> . e SMALLER e
    (45) condicao -> . e SMALLER_EQUAL e
    (46) condicao -> . e BIGGER e
    (47) condicao -> . e BIGGER_EQUAL e
    (48) condicao -> . e EQUAL e
    (49) condicao -> . e NOT_EQUAL e
    (54) logico -> . TRUE
    (55) logico -> . FALSE
    (56) logico -> . NOT logico

    ID              shift and go to state 22
    REAL            shift and go to state 23
    INTEIRO         shift and go to state 24
    CARACTER        shift and go to state 25
    -               shift and go to state 27
    (               shift and go to state 29
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    NOT             shift and go to state 33

    e                              shift and go to state 75
    condicao                       shift and go to state 26
    logico                         shift and go to state 28

state 51

    (45) condicao -> e SMALLER_EQUAL . e
    (29) e -> . ID
    (30) e -> . REAL
    (31) e -> . INTEIRO
    (32) e -> . CARACTER
    (33) e -> . condicao
    (34) e -> . - e
    (35) e -> . e * e
    (36) e -> . e / e
    (37) e -> . e + e
    (38) e -> . e - e
    (39) e -> . logico
    (40) e -> . e OR e
    (41) e -> . e AND e
    (42) e -> . e XOR e
    (43) e -> . ( e )
    (44) condicao -> . e SMALLER e
    (45) condicao -> . e SMALLER_EQUAL e
    (46) condicao -> . e BIGGER e
    (47) condicao -> . e BIGGER_EQUAL e
    (48) condicao -> . e EQUAL e
    (49) condicao -> . e NOT_EQUAL e
    (54) logico -> . TRUE
    (55) logico -> . FALSE
    (56) logico -> . NOT logico

    ID              shift and go to state 22
    REAL            shift and go to state 23
    INTEIRO         shift and go to state 24
    CARACTER        shift and go to state 25
    -               shift and go to state 27
    (               shift and go to state 29
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    NOT             shift and go to state 33

    e                              shift and go to state 76
    condicao                       shift and go to state 26
    logico                         shift and go to state 28

state 52

    (46) condicao -> e BIGGER . e
    (29) e -> . ID
    (30) e -> . REAL
    (31) e -> . INTEIRO
    (32) e -> . CARACTER
    (33) e -> . condicao
    (34) e -> . - e
    (35) e -> . e * e
    (36) e -> . e / e
    (37) e -> . e + e
    (38) e -> . e - e
    (39) e -> . logico
    (40) e -> . e OR e
    (41) e -> . e AND e
    (42) e -> . e XOR e
    (43) e -> . ( e )
    (44) condicao -> . e SMALLER e
    (45) condicao -> . e SMALLER_EQUAL e
    (46) condicao -> . e BIGGER e
    (47) condicao -> . e BIGGER_EQUAL e
    (48) condicao -> . e EQUAL e
    (49) condicao -> . e NOT_EQUAL e
    (54) logico -> . TRUE
    (55) logico -> . FALSE
    (56) logico -> . NOT logico

    ID              shift and go to state 22
    REAL            shift and go to state 23
    INTEIRO         shift and go to state 24
    CARACTER        shift and go to state 25
    -               shift and go to state 27
    (               shift and go to state 29
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    NOT             shift and go to state 33

    e                              shift and go to state 77
    condicao                       shift and go to state 26
    logico                         shift and go to state 28

state 53

    (47) condicao -> e BIGGER_EQUAL . e
    (29) e -> . ID
    (30) e -> . REAL
    (31) e -> . INTEIRO
    (32) e -> . CARACTER
    (33) e -> . condicao
    (34) e -> . - e
    (35) e -> . e * e
    (36) e -> . e / e
    (37) e -> . e + e
    (38) e -> . e - e
    (39) e -> . logico
    (40) e -> . e OR e
    (41) e -> . e AND e
    (42) e -> . e XOR e
    (43) e -> . ( e )
    (44) condicao -> . e SMALLER e
    (45) condicao -> . e SMALLER_EQUAL e
    (46) condicao -> . e BIGGER e
    (47) condicao -> . e BIGGER_EQUAL e
    (48) condicao -> . e EQUAL e
    (49) condicao -> . e NOT_EQUAL e
    (54) logico -> . TRUE
    (55) logico -> . FALSE
    (56) logico -> . NOT logico

    ID              shift and go to state 22
    REAL            shift and go to state 23
    INTEIRO         shift and go to state 24
    CARACTER        shift and go to state 25
    -               shift and go to state 27
    (               shift and go to state 29
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    NOT             shift and go to state 33

    e                              shift and go to state 78
    condicao                       shift and go to state 26
    logico                         shift and go to state 28

state 54

    (48) condicao -> e EQUAL . e
    (29) e -> . ID
    (30) e -> . REAL
    (31) e -> . INTEIRO
    (32) e -> . CARACTER
    (33) e -> . condicao
    (34) e -> . - e
    (35) e -> . e * e
    (36) e -> . e / e
    (37) e -> . e + e
    (38) e -> . e - e
    (39) e -> . logico
    (40) e -> . e OR e
    (41) e -> . e AND e
    (42) e -> . e XOR e
    (43) e -> . ( e )
    (44) condicao -> . e SMALLER e
    (45) condicao -> . e SMALLER_EQUAL e
    (46) condicao -> . e BIGGER e
    (47) condicao -> . e BIGGER_EQUAL e
    (48) condicao -> . e EQUAL e
    (49) condicao -> . e NOT_EQUAL e
    (54) logico -> . TRUE
    (55) logico -> . FALSE
    (56) logico -> . NOT logico

    ID              shift and go to state 22
    REAL            shift and go to state 23
    INTEIRO         shift and go to state 24
    CARACTER        shift and go to state 25
    -               shift and go to state 27
    (               shift and go to state 29
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    NOT             shift and go to state 33

    e                              shift and go to state 79
    condicao                       shift and go to state 26
    logico                         shift and go to state 28

state 55

    (49) condicao -> e NOT_EQUAL . e
    (29) e -> . ID
    (30) e -> . REAL
    (31) e -> . INTEIRO
    (32) e -> . CARACTER
    (33) e -> . condicao
    (34) e -> . - e
    (35) e -> . e * e
    (36) e -> . e / e
    (37) e -> . e + e
    (38) e -> . e - e
    (39) e -> . logico
    (40) e -> . e OR e
    (41) e -> . e AND e
    (42) e -> . e XOR e
    (43) e -> . ( e )
    (44) condicao -> . e SMALLER e
    (45) condicao -> . e SMALLER_EQUAL e
    (46) condicao -> . e BIGGER e
    (47) condicao -> . e BIGGER_EQUAL e
    (48) condicao -> . e EQUAL e
    (49) condicao -> . e NOT_EQUAL e
    (54) logico -> . TRUE
    (55) logico -> . FALSE
    (56) logico -> . NOT logico

    ID              shift and go to state 22
    REAL            shift and go to state 23
    INTEIRO         shift and go to state 24
    CARACTER        shift and go to state 25
    -               shift and go to state 27
    (               shift and go to state 29
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    NOT             shift and go to state 33

    e                              shift and go to state 80
    condicao                       shift and go to state 26
    logico                         shift and go to state 28

state 56

    (26) var_list -> var_list , . VAR

    VAR             shift and go to state 81


state 57

    (34) e -> - e .
    (35) e -> e . * e
    (36) e -> e . / e
    (37) e -> e . + e
    (38) e -> e . - e
    (40) e -> e . OR e
    (41) e -> e . AND e
    (42) e -> e . XOR e
    (44) condicao -> e . SMALLER e
    (45) condicao -> e . SMALLER_EQUAL e
    (46) condicao -> e . BIGGER e
    (47) condicao -> e . BIGGER_EQUAL e
    (48) condicao -> e . EQUAL e
    (49) condicao -> e . NOT_EQUAL e

    *               reduce using rule 34 (e -> - e .)
    /               reduce using rule 34 (e -> - e .)
    +               reduce using rule 34 (e -> - e .)
    -               reduce using rule 34 (e -> - e .)
    OR              reduce using rule 34 (e -> - e .)
    AND             reduce using rule 34 (e -> - e .)
    XOR             reduce using rule 34 (e -> - e .)
    SMALLER         reduce using rule 34 (e -> - e .)
    SMALLER_EQUAL   reduce using rule 34 (e -> - e .)
    BIGGER          reduce using rule 34 (e -> - e .)
    BIGGER_EQUAL    reduce using rule 34 (e -> - e .)
    EQUAL           reduce using rule 34 (e -> - e .)
    NOT_EQUAL       reduce using rule 34 (e -> - e .)
    V               reduce using rule 34 (e -> - e .)
    ESCREVER        reduce using rule 34 (e -> - e .)
    ID              reduce using rule 34 (e -> - e .)
    PARA            reduce using rule 34 (e -> - e .)
    VAR             reduce using rule 34 (e -> - e .)
    SE              reduce using rule 34 (e -> - e .)
    FUNCAO          reduce using rule 34 (e -> - e .)
    ;               reduce using rule 34 (e -> - e .)
    FIM_SE          reduce using rule 34 (e -> - e .)
    SENAO           reduce using rule 34 (e -> - e .)
    FIM_FUNCAO      reduce using rule 34 (e -> - e .)
    FIM             reduce using rule 34 (e -> - e .)
    ENTAO           reduce using rule 34 (e -> - e .)
    )               reduce using rule 34 (e -> - e .)
    ,               reduce using rule 34 (e -> - e .)

  ! *               [ shift and go to state 43 ]
  ! /               [ shift and go to state 44 ]
  ! +               [ shift and go to state 45 ]
  ! -               [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! XOR             [ shift and go to state 49 ]
  ! SMALLER         [ shift and go to state 50 ]
  ! SMALLER_EQUAL   [ shift and go to state 51 ]
  ! BIGGER          [ shift and go to state 52 ]
  ! BIGGER_EQUAL    [ shift and go to state 53 ]
  ! EQUAL           [ shift and go to state 54 ]
  ! NOT_EQUAL       [ shift and go to state 55 ]


state 58

    (43) e -> ( e . )
    (35) e -> e . * e
    (36) e -> e . / e
    (37) e -> e . + e
    (38) e -> e . - e
    (40) e -> e . OR e
    (41) e -> e . AND e
    (42) e -> e . XOR e
    (44) condicao -> e . SMALLER e
    (45) condicao -> e . SMALLER_EQUAL e
    (46) condicao -> e . BIGGER e
    (47) condicao -> e . BIGGER_EQUAL e
    (48) condicao -> e . EQUAL e
    (49) condicao -> e . NOT_EQUAL e

    )               shift and go to state 82
    *               shift and go to state 43
    /               shift and go to state 44
    +               shift and go to state 45
    -               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    XOR             shift and go to state 49
    SMALLER         shift and go to state 50
    SMALLER_EQUAL   shift and go to state 51
    BIGGER          shift and go to state 52
    BIGGER_EQUAL    shift and go to state 53
    EQUAL           shift and go to state 54
    NOT_EQUAL       shift and go to state 55


state 59

    (56) logico -> NOT logico .

    *               reduce using rule 56 (logico -> NOT logico .)
    /               reduce using rule 56 (logico -> NOT logico .)
    +               reduce using rule 56 (logico -> NOT logico .)
    -               reduce using rule 56 (logico -> NOT logico .)
    OR              reduce using rule 56 (logico -> NOT logico .)
    AND             reduce using rule 56 (logico -> NOT logico .)
    XOR             reduce using rule 56 (logico -> NOT logico .)
    SMALLER         reduce using rule 56 (logico -> NOT logico .)
    SMALLER_EQUAL   reduce using rule 56 (logico -> NOT logico .)
    BIGGER          reduce using rule 56 (logico -> NOT logico .)
    BIGGER_EQUAL    reduce using rule 56 (logico -> NOT logico .)
    EQUAL           reduce using rule 56 (logico -> NOT logico .)
    NOT_EQUAL       reduce using rule 56 (logico -> NOT logico .)
    V               reduce using rule 56 (logico -> NOT logico .)
    ESCREVER        reduce using rule 56 (logico -> NOT logico .)
    ID              reduce using rule 56 (logico -> NOT logico .)
    PARA            reduce using rule 56 (logico -> NOT logico .)
    VAR             reduce using rule 56 (logico -> NOT logico .)
    SE              reduce using rule 56 (logico -> NOT logico .)
    FUNCAO          reduce using rule 56 (logico -> NOT logico .)
    ;               reduce using rule 56 (logico -> NOT logico .)
    FIM_SE          reduce using rule 56 (logico -> NOT logico .)
    SENAO           reduce using rule 56 (logico -> NOT logico .)
    FIM_FUNCAO      reduce using rule 56 (logico -> NOT logico .)
    FIM             reduce using rule 56 (logico -> NOT logico .)
    ENTAO           reduce using rule 56 (logico -> NOT logico .)
    )               reduce using rule 56 (logico -> NOT logico .)
    ,               reduce using rule 56 (logico -> NOT logico .)


state 60

    (10) command -> ID ATRIBUICAO e_list .
    (28) e_list -> e_list . , e

    V               reduce using rule 10 (command -> ID ATRIBUICAO e_list .)
    ESCREVER        reduce using rule 10 (command -> ID ATRIBUICAO e_list .)
    ID              reduce using rule 10 (command -> ID ATRIBUICAO e_list .)
    PARA            reduce using rule 10 (command -> ID ATRIBUICAO e_list .)
    VAR             reduce using rule 10 (command -> ID ATRIBUICAO e_list .)
    SE              reduce using rule 10 (command -> ID ATRIBUICAO e_list .)
    FUNCAO          reduce using rule 10 (command -> ID ATRIBUICAO e_list .)
    ;               reduce using rule 10 (command -> ID ATRIBUICAO e_list .)
    FIM_SE          reduce using rule 10 (command -> ID ATRIBUICAO e_list .)
    SENAO           reduce using rule 10 (command -> ID ATRIBUICAO e_list .)
    FIM_FUNCAO      reduce using rule 10 (command -> ID ATRIBUICAO e_list .)
    FIM             reduce using rule 10 (command -> ID ATRIBUICAO e_list .)
    ,               shift and go to state 83


state 61

    (27) e_list -> e .
    (35) e -> e . * e
    (36) e -> e . / e
    (37) e -> e . + e
    (38) e -> e . - e
    (40) e -> e . OR e
    (41) e -> e . AND e
    (42) e -> e . XOR e
    (44) condicao -> e . SMALLER e
    (45) condicao -> e . SMALLER_EQUAL e
    (46) condicao -> e . BIGGER e
    (47) condicao -> e . BIGGER_EQUAL e
    (48) condicao -> e . EQUAL e
    (49) condicao -> e . NOT_EQUAL e

    ,               reduce using rule 27 (e_list -> e .)
    V               reduce using rule 27 (e_list -> e .)
    ESCREVER        reduce using rule 27 (e_list -> e .)
    ID              reduce using rule 27 (e_list -> e .)
    PARA            reduce using rule 27 (e_list -> e .)
    VAR             reduce using rule 27 (e_list -> e .)
    SE              reduce using rule 27 (e_list -> e .)
    FUNCAO          reduce using rule 27 (e_list -> e .)
    ;               reduce using rule 27 (e_list -> e .)
    FIM_SE          reduce using rule 27 (e_list -> e .)
    SENAO           reduce using rule 27 (e_list -> e .)
    FIM_FUNCAO      reduce using rule 27 (e_list -> e .)
    FIM             reduce using rule 27 (e_list -> e .)
    )               reduce using rule 27 (e_list -> e .)
    *               shift and go to state 43
    /               shift and go to state 44
    +               shift and go to state 45
    -               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    XOR             shift and go to state 49
    SMALLER         shift and go to state 50
    SMALLER_EQUAL   shift and go to state 51
    BIGGER          shift and go to state 52
    BIGGER_EQUAL    shift and go to state 53
    EQUAL           shift and go to state 54
    NOT_EQUAL       shift and go to state 55


state 62

    (15) ciclo_for -> PARA ID EM . [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM

    [               shift and go to state 84


state 63

    (20) callfunc -> VAR ( e_list . )
    (28) e_list -> e_list . , e

    )               shift and go to state 85
    ,               shift and go to state 83


state 64

    (21) callfunc -> VAR ( ) .

    ;               reduce using rule 21 (callfunc -> VAR ( ) .)


state 65

    (16) if -> SE e ENTAO . com_list FIM_SE
    (17) if -> SE e ENTAO . com_list SENAO com_list FIM_SE
    (4) com_list -> . command
    (5) com_list -> . com_list command
    (6) command -> . V STRING ATRIBUICAO var_list
    (7) command -> . ESCREVER STRING ;
    (8) command -> . ESCREVER e
    (9) command -> . ESCREVER var_list
    (10) command -> . ID ATRIBUICAO e_list
    (11) command -> . ciclo_for
    (12) command -> . callfunc ;
    (13) command -> . if
    (14) command -> . func
    (15) ciclo_for -> . PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM
    (20) callfunc -> . VAR ( e_list )
    (21) callfunc -> . VAR ( )
    (16) if -> . SE e ENTAO com_list FIM_SE
    (17) if -> . SE e ENTAO com_list SENAO com_list FIM_SE
    (18) func -> . FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO
    (19) func -> . FUNCAO VAR ( ) com_list FIM_FUNCAO

    V               shift and go to state 5
    ESCREVER        shift and go to state 6
    ID              shift and go to state 7
    PARA            shift and go to state 12
    VAR             shift and go to state 13
    SE              shift and go to state 14
    FUNCAO          shift and go to state 15

    com_list                       shift and go to state 86
    command                        shift and go to state 3
    ciclo_for                      shift and go to state 8
    callfunc                       shift and go to state 9
    if                             shift and go to state 10
    func                           shift and go to state 11

state 66

    (18) func -> FUNCAO VAR ( . var_fun_list ) com_list FIM_FUNCAO
    (19) func -> FUNCAO VAR ( . ) com_list FIM_FUNCAO
    (22) var_fun_list -> . var_fun
    (23) var_fun_list -> . var_fun_list , var_fun
    (24) var_fun -> . type VAR
    (50) type -> . DEFINITION_INTEIRO
    (51) type -> . DEFINITION_REAL
    (52) type -> . DEFINITION_CARACTER
    (53) type -> . DEFENITION_LOGICO

    )               shift and go to state 88
    DEFINITION_INTEIRO shift and go to state 91
    DEFINITION_REAL shift and go to state 92
    DEFINITION_CARACTER shift and go to state 93
    DEFENITION_LOGICO shift and go to state 94

    var_fun_list                   shift and go to state 87
    var_fun                        shift and go to state 89
    type                           shift and go to state 90

state 67

    (6) command -> V STRING ATRIBUICAO var_list .
    (26) var_list -> var_list . , VAR

    V               reduce using rule 6 (command -> V STRING ATRIBUICAO var_list .)
    ESCREVER        reduce using rule 6 (command -> V STRING ATRIBUICAO var_list .)
    ID              reduce using rule 6 (command -> V STRING ATRIBUICAO var_list .)
    PARA            reduce using rule 6 (command -> V STRING ATRIBUICAO var_list .)
    VAR             reduce using rule 6 (command -> V STRING ATRIBUICAO var_list .)
    SE              reduce using rule 6 (command -> V STRING ATRIBUICAO var_list .)
    FUNCAO          reduce using rule 6 (command -> V STRING ATRIBUICAO var_list .)
    ;               reduce using rule 6 (command -> V STRING ATRIBUICAO var_list .)
    FIM_SE          reduce using rule 6 (command -> V STRING ATRIBUICAO var_list .)
    SENAO           reduce using rule 6 (command -> V STRING ATRIBUICAO var_list .)
    FIM_FUNCAO      reduce using rule 6 (command -> V STRING ATRIBUICAO var_list .)
    FIM             reduce using rule 6 (command -> V STRING ATRIBUICAO var_list .)
    ,               shift and go to state 56


state 68

    (35) e -> e * e .
    (35) e -> e . * e
    (36) e -> e . / e
    (37) e -> e . + e
    (38) e -> e . - e
    (40) e -> e . OR e
    (41) e -> e . AND e
    (42) e -> e . XOR e
    (44) condicao -> e . SMALLER e
    (45) condicao -> e . SMALLER_EQUAL e
    (46) condicao -> e . BIGGER e
    (47) condicao -> e . BIGGER_EQUAL e
    (48) condicao -> e . EQUAL e
    (49) condicao -> e . NOT_EQUAL e

    *               reduce using rule 35 (e -> e * e .)
    /               reduce using rule 35 (e -> e * e .)
    +               reduce using rule 35 (e -> e * e .)
    -               reduce using rule 35 (e -> e * e .)
    OR              reduce using rule 35 (e -> e * e .)
    AND             reduce using rule 35 (e -> e * e .)
    XOR             reduce using rule 35 (e -> e * e .)
    SMALLER         reduce using rule 35 (e -> e * e .)
    SMALLER_EQUAL   reduce using rule 35 (e -> e * e .)
    BIGGER          reduce using rule 35 (e -> e * e .)
    BIGGER_EQUAL    reduce using rule 35 (e -> e * e .)
    EQUAL           reduce using rule 35 (e -> e * e .)
    NOT_EQUAL       reduce using rule 35 (e -> e * e .)
    V               reduce using rule 35 (e -> e * e .)
    ESCREVER        reduce using rule 35 (e -> e * e .)
    ID              reduce using rule 35 (e -> e * e .)
    PARA            reduce using rule 35 (e -> e * e .)
    VAR             reduce using rule 35 (e -> e * e .)
    SE              reduce using rule 35 (e -> e * e .)
    FUNCAO          reduce using rule 35 (e -> e * e .)
    ;               reduce using rule 35 (e -> e * e .)
    FIM_SE          reduce using rule 35 (e -> e * e .)
    SENAO           reduce using rule 35 (e -> e * e .)
    FIM_FUNCAO      reduce using rule 35 (e -> e * e .)
    FIM             reduce using rule 35 (e -> e * e .)
    ENTAO           reduce using rule 35 (e -> e * e .)
    )               reduce using rule 35 (e -> e * e .)
    ,               reduce using rule 35 (e -> e * e .)

  ! *               [ shift and go to state 43 ]
  ! /               [ shift and go to state 44 ]
  ! +               [ shift and go to state 45 ]
  ! -               [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! XOR             [ shift and go to state 49 ]
  ! SMALLER         [ shift and go to state 50 ]
  ! SMALLER_EQUAL   [ shift and go to state 51 ]
  ! BIGGER          [ shift and go to state 52 ]
  ! BIGGER_EQUAL    [ shift and go to state 53 ]
  ! EQUAL           [ shift and go to state 54 ]
  ! NOT_EQUAL       [ shift and go to state 55 ]


state 69

    (36) e -> e / e .
    (35) e -> e . * e
    (36) e -> e . / e
    (37) e -> e . + e
    (38) e -> e . - e
    (40) e -> e . OR e
    (41) e -> e . AND e
    (42) e -> e . XOR e
    (44) condicao -> e . SMALLER e
    (45) condicao -> e . SMALLER_EQUAL e
    (46) condicao -> e . BIGGER e
    (47) condicao -> e . BIGGER_EQUAL e
    (48) condicao -> e . EQUAL e
    (49) condicao -> e . NOT_EQUAL e

    *               reduce using rule 36 (e -> e / e .)
    /               reduce using rule 36 (e -> e / e .)
    +               reduce using rule 36 (e -> e / e .)
    -               reduce using rule 36 (e -> e / e .)
    OR              reduce using rule 36 (e -> e / e .)
    AND             reduce using rule 36 (e -> e / e .)
    XOR             reduce using rule 36 (e -> e / e .)
    SMALLER         reduce using rule 36 (e -> e / e .)
    SMALLER_EQUAL   reduce using rule 36 (e -> e / e .)
    BIGGER          reduce using rule 36 (e -> e / e .)
    BIGGER_EQUAL    reduce using rule 36 (e -> e / e .)
    EQUAL           reduce using rule 36 (e -> e / e .)
    NOT_EQUAL       reduce using rule 36 (e -> e / e .)
    V               reduce using rule 36 (e -> e / e .)
    ESCREVER        reduce using rule 36 (e -> e / e .)
    ID              reduce using rule 36 (e -> e / e .)
    PARA            reduce using rule 36 (e -> e / e .)
    VAR             reduce using rule 36 (e -> e / e .)
    SE              reduce using rule 36 (e -> e / e .)
    FUNCAO          reduce using rule 36 (e -> e / e .)
    ;               reduce using rule 36 (e -> e / e .)
    FIM_SE          reduce using rule 36 (e -> e / e .)
    SENAO           reduce using rule 36 (e -> e / e .)
    FIM_FUNCAO      reduce using rule 36 (e -> e / e .)
    FIM             reduce using rule 36 (e -> e / e .)
    ENTAO           reduce using rule 36 (e -> e / e .)
    )               reduce using rule 36 (e -> e / e .)
    ,               reduce using rule 36 (e -> e / e .)

  ! *               [ shift and go to state 43 ]
  ! /               [ shift and go to state 44 ]
  ! +               [ shift and go to state 45 ]
  ! -               [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! XOR             [ shift and go to state 49 ]
  ! SMALLER         [ shift and go to state 50 ]
  ! SMALLER_EQUAL   [ shift and go to state 51 ]
  ! BIGGER          [ shift and go to state 52 ]
  ! BIGGER_EQUAL    [ shift and go to state 53 ]
  ! EQUAL           [ shift and go to state 54 ]
  ! NOT_EQUAL       [ shift and go to state 55 ]


state 70

    (37) e -> e + e .
    (35) e -> e . * e
    (36) e -> e . / e
    (37) e -> e . + e
    (38) e -> e . - e
    (40) e -> e . OR e
    (41) e -> e . AND e
    (42) e -> e . XOR e
    (44) condicao -> e . SMALLER e
    (45) condicao -> e . SMALLER_EQUAL e
    (46) condicao -> e . BIGGER e
    (47) condicao -> e . BIGGER_EQUAL e
    (48) condicao -> e . EQUAL e
    (49) condicao -> e . NOT_EQUAL e

    +               reduce using rule 37 (e -> e + e .)
    -               reduce using rule 37 (e -> e + e .)
    OR              reduce using rule 37 (e -> e + e .)
    AND             reduce using rule 37 (e -> e + e .)
    XOR             reduce using rule 37 (e -> e + e .)
    SMALLER         reduce using rule 37 (e -> e + e .)
    SMALLER_EQUAL   reduce using rule 37 (e -> e + e .)
    BIGGER          reduce using rule 37 (e -> e + e .)
    BIGGER_EQUAL    reduce using rule 37 (e -> e + e .)
    EQUAL           reduce using rule 37 (e -> e + e .)
    NOT_EQUAL       reduce using rule 37 (e -> e + e .)
    V               reduce using rule 37 (e -> e + e .)
    ESCREVER        reduce using rule 37 (e -> e + e .)
    ID              reduce using rule 37 (e -> e + e .)
    PARA            reduce using rule 37 (e -> e + e .)
    VAR             reduce using rule 37 (e -> e + e .)
    SE              reduce using rule 37 (e -> e + e .)
    FUNCAO          reduce using rule 37 (e -> e + e .)
    ;               reduce using rule 37 (e -> e + e .)
    FIM_SE          reduce using rule 37 (e -> e + e .)
    SENAO           reduce using rule 37 (e -> e + e .)
    FIM_FUNCAO      reduce using rule 37 (e -> e + e .)
    FIM             reduce using rule 37 (e -> e + e .)
    ENTAO           reduce using rule 37 (e -> e + e .)
    )               reduce using rule 37 (e -> e + e .)
    ,               reduce using rule 37 (e -> e + e .)
    *               shift and go to state 43
    /               shift and go to state 44

  ! *               [ reduce using rule 37 (e -> e + e .) ]
  ! /               [ reduce using rule 37 (e -> e + e .) ]
  ! +               [ shift and go to state 45 ]
  ! -               [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! XOR             [ shift and go to state 49 ]
  ! SMALLER         [ shift and go to state 50 ]
  ! SMALLER_EQUAL   [ shift and go to state 51 ]
  ! BIGGER          [ shift and go to state 52 ]
  ! BIGGER_EQUAL    [ shift and go to state 53 ]
  ! EQUAL           [ shift and go to state 54 ]
  ! NOT_EQUAL       [ shift and go to state 55 ]


state 71

    (38) e -> e - e .
    (35) e -> e . * e
    (36) e -> e . / e
    (37) e -> e . + e
    (38) e -> e . - e
    (40) e -> e . OR e
    (41) e -> e . AND e
    (42) e -> e . XOR e
    (44) condicao -> e . SMALLER e
    (45) condicao -> e . SMALLER_EQUAL e
    (46) condicao -> e . BIGGER e
    (47) condicao -> e . BIGGER_EQUAL e
    (48) condicao -> e . EQUAL e
    (49) condicao -> e . NOT_EQUAL e

    +               reduce using rule 38 (e -> e - e .)
    -               reduce using rule 38 (e -> e - e .)
    OR              reduce using rule 38 (e -> e - e .)
    AND             reduce using rule 38 (e -> e - e .)
    XOR             reduce using rule 38 (e -> e - e .)
    SMALLER         reduce using rule 38 (e -> e - e .)
    SMALLER_EQUAL   reduce using rule 38 (e -> e - e .)
    BIGGER          reduce using rule 38 (e -> e - e .)
    BIGGER_EQUAL    reduce using rule 38 (e -> e - e .)
    EQUAL           reduce using rule 38 (e -> e - e .)
    NOT_EQUAL       reduce using rule 38 (e -> e - e .)
    V               reduce using rule 38 (e -> e - e .)
    ESCREVER        reduce using rule 38 (e -> e - e .)
    ID              reduce using rule 38 (e -> e - e .)
    PARA            reduce using rule 38 (e -> e - e .)
    VAR             reduce using rule 38 (e -> e - e .)
    SE              reduce using rule 38 (e -> e - e .)
    FUNCAO          reduce using rule 38 (e -> e - e .)
    ;               reduce using rule 38 (e -> e - e .)
    FIM_SE          reduce using rule 38 (e -> e - e .)
    SENAO           reduce using rule 38 (e -> e - e .)
    FIM_FUNCAO      reduce using rule 38 (e -> e - e .)
    FIM             reduce using rule 38 (e -> e - e .)
    ENTAO           reduce using rule 38 (e -> e - e .)
    )               reduce using rule 38 (e -> e - e .)
    ,               reduce using rule 38 (e -> e - e .)
    *               shift and go to state 43
    /               shift and go to state 44

  ! *               [ reduce using rule 38 (e -> e - e .) ]
  ! /               [ reduce using rule 38 (e -> e - e .) ]
  ! +               [ shift and go to state 45 ]
  ! -               [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! XOR             [ shift and go to state 49 ]
  ! SMALLER         [ shift and go to state 50 ]
  ! SMALLER_EQUAL   [ shift and go to state 51 ]
  ! BIGGER          [ shift and go to state 52 ]
  ! BIGGER_EQUAL    [ shift and go to state 53 ]
  ! EQUAL           [ shift and go to state 54 ]
  ! NOT_EQUAL       [ shift and go to state 55 ]


state 72

    (40) e -> e OR e .
    (35) e -> e . * e
    (36) e -> e . / e
    (37) e -> e . + e
    (38) e -> e . - e
    (40) e -> e . OR e
    (41) e -> e . AND e
    (42) e -> e . XOR e
    (44) condicao -> e . SMALLER e
    (45) condicao -> e . SMALLER_EQUAL e
    (46) condicao -> e . BIGGER e
    (47) condicao -> e . BIGGER_EQUAL e
    (48) condicao -> e . EQUAL e
    (49) condicao -> e . NOT_EQUAL e

    OR              reduce using rule 40 (e -> e OR e .)
    XOR             reduce using rule 40 (e -> e OR e .)
    V               reduce using rule 40 (e -> e OR e .)
    ESCREVER        reduce using rule 40 (e -> e OR e .)
    ID              reduce using rule 40 (e -> e OR e .)
    PARA            reduce using rule 40 (e -> e OR e .)
    VAR             reduce using rule 40 (e -> e OR e .)
    SE              reduce using rule 40 (e -> e OR e .)
    FUNCAO          reduce using rule 40 (e -> e OR e .)
    ;               reduce using rule 40 (e -> e OR e .)
    FIM_SE          reduce using rule 40 (e -> e OR e .)
    SENAO           reduce using rule 40 (e -> e OR e .)
    FIM_FUNCAO      reduce using rule 40 (e -> e OR e .)
    FIM             reduce using rule 40 (e -> e OR e .)
    ENTAO           reduce using rule 40 (e -> e OR e .)
    )               reduce using rule 40 (e -> e OR e .)
    ,               reduce using rule 40 (e -> e OR e .)
    *               shift and go to state 43
    /               shift and go to state 44
    +               shift and go to state 45
    -               shift and go to state 46
    AND             shift and go to state 48
    SMALLER         shift and go to state 50
    SMALLER_EQUAL   shift and go to state 51
    BIGGER          shift and go to state 52
    BIGGER_EQUAL    shift and go to state 53
    EQUAL           shift and go to state 54
    NOT_EQUAL       shift and go to state 55

  ! *               [ reduce using rule 40 (e -> e OR e .) ]
  ! /               [ reduce using rule 40 (e -> e OR e .) ]
  ! +               [ reduce using rule 40 (e -> e OR e .) ]
  ! -               [ reduce using rule 40 (e -> e OR e .) ]
  ! AND             [ reduce using rule 40 (e -> e OR e .) ]
  ! SMALLER         [ reduce using rule 40 (e -> e OR e .) ]
  ! SMALLER_EQUAL   [ reduce using rule 40 (e -> e OR e .) ]
  ! BIGGER          [ reduce using rule 40 (e -> e OR e .) ]
  ! BIGGER_EQUAL    [ reduce using rule 40 (e -> e OR e .) ]
  ! EQUAL           [ reduce using rule 40 (e -> e OR e .) ]
  ! NOT_EQUAL       [ reduce using rule 40 (e -> e OR e .) ]
  ! OR              [ shift and go to state 47 ]
  ! XOR             [ shift and go to state 49 ]


state 73

    (41) e -> e AND e .
    (35) e -> e . * e
    (36) e -> e . / e
    (37) e -> e . + e
    (38) e -> e . - e
    (40) e -> e . OR e
    (41) e -> e . AND e
    (42) e -> e . XOR e
    (44) condicao -> e . SMALLER e
    (45) condicao -> e . SMALLER_EQUAL e
    (46) condicao -> e . BIGGER e
    (47) condicao -> e . BIGGER_EQUAL e
    (48) condicao -> e . EQUAL e
    (49) condicao -> e . NOT_EQUAL e

    OR              reduce using rule 41 (e -> e AND e .)
    AND             reduce using rule 41 (e -> e AND e .)
    XOR             reduce using rule 41 (e -> e AND e .)
    V               reduce using rule 41 (e -> e AND e .)
    ESCREVER        reduce using rule 41 (e -> e AND e .)
    ID              reduce using rule 41 (e -> e AND e .)
    PARA            reduce using rule 41 (e -> e AND e .)
    VAR             reduce using rule 41 (e -> e AND e .)
    SE              reduce using rule 41 (e -> e AND e .)
    FUNCAO          reduce using rule 41 (e -> e AND e .)
    ;               reduce using rule 41 (e -> e AND e .)
    FIM_SE          reduce using rule 41 (e -> e AND e .)
    SENAO           reduce using rule 41 (e -> e AND e .)
    FIM_FUNCAO      reduce using rule 41 (e -> e AND e .)
    FIM             reduce using rule 41 (e -> e AND e .)
    ENTAO           reduce using rule 41 (e -> e AND e .)
    )               reduce using rule 41 (e -> e AND e .)
    ,               reduce using rule 41 (e -> e AND e .)
    *               shift and go to state 43
    /               shift and go to state 44
    +               shift and go to state 45
    -               shift and go to state 46
    SMALLER         shift and go to state 50
    SMALLER_EQUAL   shift and go to state 51
    BIGGER          shift and go to state 52
    BIGGER_EQUAL    shift and go to state 53
    EQUAL           shift and go to state 54
    NOT_EQUAL       shift and go to state 55

  ! *               [ reduce using rule 41 (e -> e AND e .) ]
  ! /               [ reduce using rule 41 (e -> e AND e .) ]
  ! +               [ reduce using rule 41 (e -> e AND e .) ]
  ! -               [ reduce using rule 41 (e -> e AND e .) ]
  ! SMALLER         [ reduce using rule 41 (e -> e AND e .) ]
  ! SMALLER_EQUAL   [ reduce using rule 41 (e -> e AND e .) ]
  ! BIGGER          [ reduce using rule 41 (e -> e AND e .) ]
  ! BIGGER_EQUAL    [ reduce using rule 41 (e -> e AND e .) ]
  ! EQUAL           [ reduce using rule 41 (e -> e AND e .) ]
  ! NOT_EQUAL       [ reduce using rule 41 (e -> e AND e .) ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! XOR             [ shift and go to state 49 ]


state 74

    (42) e -> e XOR e .
    (35) e -> e . * e
    (36) e -> e . / e
    (37) e -> e . + e
    (38) e -> e . - e
    (40) e -> e . OR e
    (41) e -> e . AND e
    (42) e -> e . XOR e
    (44) condicao -> e . SMALLER e
    (45) condicao -> e . SMALLER_EQUAL e
    (46) condicao -> e . BIGGER e
    (47) condicao -> e . BIGGER_EQUAL e
    (48) condicao -> e . EQUAL e
    (49) condicao -> e . NOT_EQUAL e

    OR              reduce using rule 42 (e -> e XOR e .)
    XOR             reduce using rule 42 (e -> e XOR e .)
    V               reduce using rule 42 (e -> e XOR e .)
    ESCREVER        reduce using rule 42 (e -> e XOR e .)
    ID              reduce using rule 42 (e -> e XOR e .)
    PARA            reduce using rule 42 (e -> e XOR e .)
    VAR             reduce using rule 42 (e -> e XOR e .)
    SE              reduce using rule 42 (e -> e XOR e .)
    FUNCAO          reduce using rule 42 (e -> e XOR e .)
    ;               reduce using rule 42 (e -> e XOR e .)
    FIM_SE          reduce using rule 42 (e -> e XOR e .)
    SENAO           reduce using rule 42 (e -> e XOR e .)
    FIM_FUNCAO      reduce using rule 42 (e -> e XOR e .)
    FIM             reduce using rule 42 (e -> e XOR e .)
    ENTAO           reduce using rule 42 (e -> e XOR e .)
    )               reduce using rule 42 (e -> e XOR e .)
    ,               reduce using rule 42 (e -> e XOR e .)
    *               shift and go to state 43
    /               shift and go to state 44
    +               shift and go to state 45
    -               shift and go to state 46
    AND             shift and go to state 48
    SMALLER         shift and go to state 50
    SMALLER_EQUAL   shift and go to state 51
    BIGGER          shift and go to state 52
    BIGGER_EQUAL    shift and go to state 53
    EQUAL           shift and go to state 54
    NOT_EQUAL       shift and go to state 55

  ! *               [ reduce using rule 42 (e -> e XOR e .) ]
  ! /               [ reduce using rule 42 (e -> e XOR e .) ]
  ! +               [ reduce using rule 42 (e -> e XOR e .) ]
  ! -               [ reduce using rule 42 (e -> e XOR e .) ]
  ! AND             [ reduce using rule 42 (e -> e XOR e .) ]
  ! SMALLER         [ reduce using rule 42 (e -> e XOR e .) ]
  ! SMALLER_EQUAL   [ reduce using rule 42 (e -> e XOR e .) ]
  ! BIGGER          [ reduce using rule 42 (e -> e XOR e .) ]
  ! BIGGER_EQUAL    [ reduce using rule 42 (e -> e XOR e .) ]
  ! EQUAL           [ reduce using rule 42 (e -> e XOR e .) ]
  ! NOT_EQUAL       [ reduce using rule 42 (e -> e XOR e .) ]
  ! OR              [ shift and go to state 47 ]
  ! XOR             [ shift and go to state 49 ]


state 75

    (44) condicao -> e SMALLER e .
    (35) e -> e . * e
    (36) e -> e . / e
    (37) e -> e . + e
    (38) e -> e . - e
    (40) e -> e . OR e
    (41) e -> e . AND e
    (42) e -> e . XOR e
    (44) condicao -> e . SMALLER e
    (45) condicao -> e . SMALLER_EQUAL e
    (46) condicao -> e . BIGGER e
    (47) condicao -> e . BIGGER_EQUAL e
    (48) condicao -> e . EQUAL e
    (49) condicao -> e . NOT_EQUAL e

    OR              reduce using rule 44 (condicao -> e SMALLER e .)
    AND             reduce using rule 44 (condicao -> e SMALLER e .)
    XOR             reduce using rule 44 (condicao -> e SMALLER e .)
    SMALLER         reduce using rule 44 (condicao -> e SMALLER e .)
    SMALLER_EQUAL   reduce using rule 44 (condicao -> e SMALLER e .)
    BIGGER          reduce using rule 44 (condicao -> e SMALLER e .)
    BIGGER_EQUAL    reduce using rule 44 (condicao -> e SMALLER e .)
    EQUAL           reduce using rule 44 (condicao -> e SMALLER e .)
    NOT_EQUAL       reduce using rule 44 (condicao -> e SMALLER e .)
    V               reduce using rule 44 (condicao -> e SMALLER e .)
    ESCREVER        reduce using rule 44 (condicao -> e SMALLER e .)
    ID              reduce using rule 44 (condicao -> e SMALLER e .)
    PARA            reduce using rule 44 (condicao -> e SMALLER e .)
    VAR             reduce using rule 44 (condicao -> e SMALLER e .)
    SE              reduce using rule 44 (condicao -> e SMALLER e .)
    FUNCAO          reduce using rule 44 (condicao -> e SMALLER e .)
    ;               reduce using rule 44 (condicao -> e SMALLER e .)
    FIM_SE          reduce using rule 44 (condicao -> e SMALLER e .)
    SENAO           reduce using rule 44 (condicao -> e SMALLER e .)
    FIM_FUNCAO      reduce using rule 44 (condicao -> e SMALLER e .)
    FIM             reduce using rule 44 (condicao -> e SMALLER e .)
    ENTAO           reduce using rule 44 (condicao -> e SMALLER e .)
    )               reduce using rule 44 (condicao -> e SMALLER e .)
    ,               reduce using rule 44 (condicao -> e SMALLER e .)
    *               shift and go to state 43
    /               shift and go to state 44
    +               shift and go to state 45
    -               shift and go to state 46

  ! *               [ reduce using rule 44 (condicao -> e SMALLER e .) ]
  ! /               [ reduce using rule 44 (condicao -> e SMALLER e .) ]
  ! +               [ reduce using rule 44 (condicao -> e SMALLER e .) ]
  ! -               [ reduce using rule 44 (condicao -> e SMALLER e .) ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! XOR             [ shift and go to state 49 ]
  ! SMALLER         [ shift and go to state 50 ]
  ! SMALLER_EQUAL   [ shift and go to state 51 ]
  ! BIGGER          [ shift and go to state 52 ]
  ! BIGGER_EQUAL    [ shift and go to state 53 ]
  ! EQUAL           [ shift and go to state 54 ]
  ! NOT_EQUAL       [ shift and go to state 55 ]


state 76

    (45) condicao -> e SMALLER_EQUAL e .
    (35) e -> e . * e
    (36) e -> e . / e
    (37) e -> e . + e
    (38) e -> e . - e
    (40) e -> e . OR e
    (41) e -> e . AND e
    (42) e -> e . XOR e
    (44) condicao -> e . SMALLER e
    (45) condicao -> e . SMALLER_EQUAL e
    (46) condicao -> e . BIGGER e
    (47) condicao -> e . BIGGER_EQUAL e
    (48) condicao -> e . EQUAL e
    (49) condicao -> e . NOT_EQUAL e

    OR              reduce using rule 45 (condicao -> e SMALLER_EQUAL e .)
    AND             reduce using rule 45 (condicao -> e SMALLER_EQUAL e .)
    XOR             reduce using rule 45 (condicao -> e SMALLER_EQUAL e .)
    SMALLER         reduce using rule 45 (condicao -> e SMALLER_EQUAL e .)
    SMALLER_EQUAL   reduce using rule 45 (condicao -> e SMALLER_EQUAL e .)
    BIGGER          reduce using rule 45 (condicao -> e SMALLER_EQUAL e .)
    BIGGER_EQUAL    reduce using rule 45 (condicao -> e SMALLER_EQUAL e .)
    EQUAL           reduce using rule 45 (condicao -> e SMALLER_EQUAL e .)
    NOT_EQUAL       reduce using rule 45 (condicao -> e SMALLER_EQUAL e .)
    V               reduce using rule 45 (condicao -> e SMALLER_EQUAL e .)
    ESCREVER        reduce using rule 45 (condicao -> e SMALLER_EQUAL e .)
    ID              reduce using rule 45 (condicao -> e SMALLER_EQUAL e .)
    PARA            reduce using rule 45 (condicao -> e SMALLER_EQUAL e .)
    VAR             reduce using rule 45 (condicao -> e SMALLER_EQUAL e .)
    SE              reduce using rule 45 (condicao -> e SMALLER_EQUAL e .)
    FUNCAO          reduce using rule 45 (condicao -> e SMALLER_EQUAL e .)
    ;               reduce using rule 45 (condicao -> e SMALLER_EQUAL e .)
    FIM_SE          reduce using rule 45 (condicao -> e SMALLER_EQUAL e .)
    SENAO           reduce using rule 45 (condicao -> e SMALLER_EQUAL e .)
    FIM_FUNCAO      reduce using rule 45 (condicao -> e SMALLER_EQUAL e .)
    FIM             reduce using rule 45 (condicao -> e SMALLER_EQUAL e .)
    ENTAO           reduce using rule 45 (condicao -> e SMALLER_EQUAL e .)
    )               reduce using rule 45 (condicao -> e SMALLER_EQUAL e .)
    ,               reduce using rule 45 (condicao -> e SMALLER_EQUAL e .)
    *               shift and go to state 43
    /               shift and go to state 44
    +               shift and go to state 45
    -               shift and go to state 46

  ! *               [ reduce using rule 45 (condicao -> e SMALLER_EQUAL e .) ]
  ! /               [ reduce using rule 45 (condicao -> e SMALLER_EQUAL e .) ]
  ! +               [ reduce using rule 45 (condicao -> e SMALLER_EQUAL e .) ]
  ! -               [ reduce using rule 45 (condicao -> e SMALLER_EQUAL e .) ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! XOR             [ shift and go to state 49 ]
  ! SMALLER         [ shift and go to state 50 ]
  ! SMALLER_EQUAL   [ shift and go to state 51 ]
  ! BIGGER          [ shift and go to state 52 ]
  ! BIGGER_EQUAL    [ shift and go to state 53 ]
  ! EQUAL           [ shift and go to state 54 ]
  ! NOT_EQUAL       [ shift and go to state 55 ]


state 77

    (46) condicao -> e BIGGER e .
    (35) e -> e . * e
    (36) e -> e . / e
    (37) e -> e . + e
    (38) e -> e . - e
    (40) e -> e . OR e
    (41) e -> e . AND e
    (42) e -> e . XOR e
    (44) condicao -> e . SMALLER e
    (45) condicao -> e . SMALLER_EQUAL e
    (46) condicao -> e . BIGGER e
    (47) condicao -> e . BIGGER_EQUAL e
    (48) condicao -> e . EQUAL e
    (49) condicao -> e . NOT_EQUAL e

    OR              reduce using rule 46 (condicao -> e BIGGER e .)
    AND             reduce using rule 46 (condicao -> e BIGGER e .)
    XOR             reduce using rule 46 (condicao -> e BIGGER e .)
    SMALLER         reduce using rule 46 (condicao -> e BIGGER e .)
    SMALLER_EQUAL   reduce using rule 46 (condicao -> e BIGGER e .)
    BIGGER          reduce using rule 46 (condicao -> e BIGGER e .)
    BIGGER_EQUAL    reduce using rule 46 (condicao -> e BIGGER e .)
    EQUAL           reduce using rule 46 (condicao -> e BIGGER e .)
    NOT_EQUAL       reduce using rule 46 (condicao -> e BIGGER e .)
    V               reduce using rule 46 (condicao -> e BIGGER e .)
    ESCREVER        reduce using rule 46 (condicao -> e BIGGER e .)
    ID              reduce using rule 46 (condicao -> e BIGGER e .)
    PARA            reduce using rule 46 (condicao -> e BIGGER e .)
    VAR             reduce using rule 46 (condicao -> e BIGGER e .)
    SE              reduce using rule 46 (condicao -> e BIGGER e .)
    FUNCAO          reduce using rule 46 (condicao -> e BIGGER e .)
    ;               reduce using rule 46 (condicao -> e BIGGER e .)
    FIM_SE          reduce using rule 46 (condicao -> e BIGGER e .)
    SENAO           reduce using rule 46 (condicao -> e BIGGER e .)
    FIM_FUNCAO      reduce using rule 46 (condicao -> e BIGGER e .)
    FIM             reduce using rule 46 (condicao -> e BIGGER e .)
    ENTAO           reduce using rule 46 (condicao -> e BIGGER e .)
    )               reduce using rule 46 (condicao -> e BIGGER e .)
    ,               reduce using rule 46 (condicao -> e BIGGER e .)
    *               shift and go to state 43
    /               shift and go to state 44
    +               shift and go to state 45
    -               shift and go to state 46

  ! *               [ reduce using rule 46 (condicao -> e BIGGER e .) ]
  ! /               [ reduce using rule 46 (condicao -> e BIGGER e .) ]
  ! +               [ reduce using rule 46 (condicao -> e BIGGER e .) ]
  ! -               [ reduce using rule 46 (condicao -> e BIGGER e .) ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! XOR             [ shift and go to state 49 ]
  ! SMALLER         [ shift and go to state 50 ]
  ! SMALLER_EQUAL   [ shift and go to state 51 ]
  ! BIGGER          [ shift and go to state 52 ]
  ! BIGGER_EQUAL    [ shift and go to state 53 ]
  ! EQUAL           [ shift and go to state 54 ]
  ! NOT_EQUAL       [ shift and go to state 55 ]


state 78

    (47) condicao -> e BIGGER_EQUAL e .
    (35) e -> e . * e
    (36) e -> e . / e
    (37) e -> e . + e
    (38) e -> e . - e
    (40) e -> e . OR e
    (41) e -> e . AND e
    (42) e -> e . XOR e
    (44) condicao -> e . SMALLER e
    (45) condicao -> e . SMALLER_EQUAL e
    (46) condicao -> e . BIGGER e
    (47) condicao -> e . BIGGER_EQUAL e
    (48) condicao -> e . EQUAL e
    (49) condicao -> e . NOT_EQUAL e

    OR              reduce using rule 47 (condicao -> e BIGGER_EQUAL e .)
    AND             reduce using rule 47 (condicao -> e BIGGER_EQUAL e .)
    XOR             reduce using rule 47 (condicao -> e BIGGER_EQUAL e .)
    SMALLER         reduce using rule 47 (condicao -> e BIGGER_EQUAL e .)
    SMALLER_EQUAL   reduce using rule 47 (condicao -> e BIGGER_EQUAL e .)
    BIGGER          reduce using rule 47 (condicao -> e BIGGER_EQUAL e .)
    BIGGER_EQUAL    reduce using rule 47 (condicao -> e BIGGER_EQUAL e .)
    EQUAL           reduce using rule 47 (condicao -> e BIGGER_EQUAL e .)
    NOT_EQUAL       reduce using rule 47 (condicao -> e BIGGER_EQUAL e .)
    V               reduce using rule 47 (condicao -> e BIGGER_EQUAL e .)
    ESCREVER        reduce using rule 47 (condicao -> e BIGGER_EQUAL e .)
    ID              reduce using rule 47 (condicao -> e BIGGER_EQUAL e .)
    PARA            reduce using rule 47 (condicao -> e BIGGER_EQUAL e .)
    VAR             reduce using rule 47 (condicao -> e BIGGER_EQUAL e .)
    SE              reduce using rule 47 (condicao -> e BIGGER_EQUAL e .)
    FUNCAO          reduce using rule 47 (condicao -> e BIGGER_EQUAL e .)
    ;               reduce using rule 47 (condicao -> e BIGGER_EQUAL e .)
    FIM_SE          reduce using rule 47 (condicao -> e BIGGER_EQUAL e .)
    SENAO           reduce using rule 47 (condicao -> e BIGGER_EQUAL e .)
    FIM_FUNCAO      reduce using rule 47 (condicao -> e BIGGER_EQUAL e .)
    FIM             reduce using rule 47 (condicao -> e BIGGER_EQUAL e .)
    ENTAO           reduce using rule 47 (condicao -> e BIGGER_EQUAL e .)
    )               reduce using rule 47 (condicao -> e BIGGER_EQUAL e .)
    ,               reduce using rule 47 (condicao -> e BIGGER_EQUAL e .)
    *               shift and go to state 43
    /               shift and go to state 44
    +               shift and go to state 45
    -               shift and go to state 46

  ! *               [ reduce using rule 47 (condicao -> e BIGGER_EQUAL e .) ]
  ! /               [ reduce using rule 47 (condicao -> e BIGGER_EQUAL e .) ]
  ! +               [ reduce using rule 47 (condicao -> e BIGGER_EQUAL e .) ]
  ! -               [ reduce using rule 47 (condicao -> e BIGGER_EQUAL e .) ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! XOR             [ shift and go to state 49 ]
  ! SMALLER         [ shift and go to state 50 ]
  ! SMALLER_EQUAL   [ shift and go to state 51 ]
  ! BIGGER          [ shift and go to state 52 ]
  ! BIGGER_EQUAL    [ shift and go to state 53 ]
  ! EQUAL           [ shift and go to state 54 ]
  ! NOT_EQUAL       [ shift and go to state 55 ]


state 79

    (48) condicao -> e EQUAL e .
    (35) e -> e . * e
    (36) e -> e . / e
    (37) e -> e . + e
    (38) e -> e . - e
    (40) e -> e . OR e
    (41) e -> e . AND e
    (42) e -> e . XOR e
    (44) condicao -> e . SMALLER e
    (45) condicao -> e . SMALLER_EQUAL e
    (46) condicao -> e . BIGGER e
    (47) condicao -> e . BIGGER_EQUAL e
    (48) condicao -> e . EQUAL e
    (49) condicao -> e . NOT_EQUAL e

    OR              reduce using rule 48 (condicao -> e EQUAL e .)
    AND             reduce using rule 48 (condicao -> e EQUAL e .)
    XOR             reduce using rule 48 (condicao -> e EQUAL e .)
    SMALLER         reduce using rule 48 (condicao -> e EQUAL e .)
    SMALLER_EQUAL   reduce using rule 48 (condicao -> e EQUAL e .)
    BIGGER          reduce using rule 48 (condicao -> e EQUAL e .)
    BIGGER_EQUAL    reduce using rule 48 (condicao -> e EQUAL e .)
    EQUAL           reduce using rule 48 (condicao -> e EQUAL e .)
    NOT_EQUAL       reduce using rule 48 (condicao -> e EQUAL e .)
    V               reduce using rule 48 (condicao -> e EQUAL e .)
    ESCREVER        reduce using rule 48 (condicao -> e EQUAL e .)
    ID              reduce using rule 48 (condicao -> e EQUAL e .)
    PARA            reduce using rule 48 (condicao -> e EQUAL e .)
    VAR             reduce using rule 48 (condicao -> e EQUAL e .)
    SE              reduce using rule 48 (condicao -> e EQUAL e .)
    FUNCAO          reduce using rule 48 (condicao -> e EQUAL e .)
    ;               reduce using rule 48 (condicao -> e EQUAL e .)
    FIM_SE          reduce using rule 48 (condicao -> e EQUAL e .)
    SENAO           reduce using rule 48 (condicao -> e EQUAL e .)
    FIM_FUNCAO      reduce using rule 48 (condicao -> e EQUAL e .)
    FIM             reduce using rule 48 (condicao -> e EQUAL e .)
    ENTAO           reduce using rule 48 (condicao -> e EQUAL e .)
    )               reduce using rule 48 (condicao -> e EQUAL e .)
    ,               reduce using rule 48 (condicao -> e EQUAL e .)
    *               shift and go to state 43
    /               shift and go to state 44
    +               shift and go to state 45
    -               shift and go to state 46

  ! *               [ reduce using rule 48 (condicao -> e EQUAL e .) ]
  ! /               [ reduce using rule 48 (condicao -> e EQUAL e .) ]
  ! +               [ reduce using rule 48 (condicao -> e EQUAL e .) ]
  ! -               [ reduce using rule 48 (condicao -> e EQUAL e .) ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! XOR             [ shift and go to state 49 ]
  ! SMALLER         [ shift and go to state 50 ]
  ! SMALLER_EQUAL   [ shift and go to state 51 ]
  ! BIGGER          [ shift and go to state 52 ]
  ! BIGGER_EQUAL    [ shift and go to state 53 ]
  ! EQUAL           [ shift and go to state 54 ]
  ! NOT_EQUAL       [ shift and go to state 55 ]


state 80

    (49) condicao -> e NOT_EQUAL e .
    (35) e -> e . * e
    (36) e -> e . / e
    (37) e -> e . + e
    (38) e -> e . - e
    (40) e -> e . OR e
    (41) e -> e . AND e
    (42) e -> e . XOR e
    (44) condicao -> e . SMALLER e
    (45) condicao -> e . SMALLER_EQUAL e
    (46) condicao -> e . BIGGER e
    (47) condicao -> e . BIGGER_EQUAL e
    (48) condicao -> e . EQUAL e
    (49) condicao -> e . NOT_EQUAL e

    OR              reduce using rule 49 (condicao -> e NOT_EQUAL e .)
    AND             reduce using rule 49 (condicao -> e NOT_EQUAL e .)
    XOR             reduce using rule 49 (condicao -> e NOT_EQUAL e .)
    SMALLER         reduce using rule 49 (condicao -> e NOT_EQUAL e .)
    SMALLER_EQUAL   reduce using rule 49 (condicao -> e NOT_EQUAL e .)
    BIGGER          reduce using rule 49 (condicao -> e NOT_EQUAL e .)
    BIGGER_EQUAL    reduce using rule 49 (condicao -> e NOT_EQUAL e .)
    EQUAL           reduce using rule 49 (condicao -> e NOT_EQUAL e .)
    NOT_EQUAL       reduce using rule 49 (condicao -> e NOT_EQUAL e .)
    V               reduce using rule 49 (condicao -> e NOT_EQUAL e .)
    ESCREVER        reduce using rule 49 (condicao -> e NOT_EQUAL e .)
    ID              reduce using rule 49 (condicao -> e NOT_EQUAL e .)
    PARA            reduce using rule 49 (condicao -> e NOT_EQUAL e .)
    VAR             reduce using rule 49 (condicao -> e NOT_EQUAL e .)
    SE              reduce using rule 49 (condicao -> e NOT_EQUAL e .)
    FUNCAO          reduce using rule 49 (condicao -> e NOT_EQUAL e .)
    ;               reduce using rule 49 (condicao -> e NOT_EQUAL e .)
    FIM_SE          reduce using rule 49 (condicao -> e NOT_EQUAL e .)
    SENAO           reduce using rule 49 (condicao -> e NOT_EQUAL e .)
    FIM_FUNCAO      reduce using rule 49 (condicao -> e NOT_EQUAL e .)
    FIM             reduce using rule 49 (condicao -> e NOT_EQUAL e .)
    ENTAO           reduce using rule 49 (condicao -> e NOT_EQUAL e .)
    )               reduce using rule 49 (condicao -> e NOT_EQUAL e .)
    ,               reduce using rule 49 (condicao -> e NOT_EQUAL e .)
    *               shift and go to state 43
    /               shift and go to state 44
    +               shift and go to state 45
    -               shift and go to state 46

  ! *               [ reduce using rule 49 (condicao -> e NOT_EQUAL e .) ]
  ! /               [ reduce using rule 49 (condicao -> e NOT_EQUAL e .) ]
  ! +               [ reduce using rule 49 (condicao -> e NOT_EQUAL e .) ]
  ! -               [ reduce using rule 49 (condicao -> e NOT_EQUAL e .) ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! XOR             [ shift and go to state 49 ]
  ! SMALLER         [ shift and go to state 50 ]
  ! SMALLER_EQUAL   [ shift and go to state 51 ]
  ! BIGGER          [ shift and go to state 52 ]
  ! BIGGER_EQUAL    [ shift and go to state 53 ]
  ! EQUAL           [ shift and go to state 54 ]
  ! NOT_EQUAL       [ shift and go to state 55 ]


state 81

    (26) var_list -> var_list , VAR .

    ,               reduce using rule 26 (var_list -> var_list , VAR .)
    V               reduce using rule 26 (var_list -> var_list , VAR .)
    ESCREVER        reduce using rule 26 (var_list -> var_list , VAR .)
    ID              reduce using rule 26 (var_list -> var_list , VAR .)
    PARA            reduce using rule 26 (var_list -> var_list , VAR .)
    VAR             reduce using rule 26 (var_list -> var_list , VAR .)
    SE              reduce using rule 26 (var_list -> var_list , VAR .)
    FUNCAO          reduce using rule 26 (var_list -> var_list , VAR .)
    ;               reduce using rule 26 (var_list -> var_list , VAR .)
    FIM_SE          reduce using rule 26 (var_list -> var_list , VAR .)
    SENAO           reduce using rule 26 (var_list -> var_list , VAR .)
    FIM_FUNCAO      reduce using rule 26 (var_list -> var_list , VAR .)
    FIM             reduce using rule 26 (var_list -> var_list , VAR .)


state 82

    (43) e -> ( e ) .

    *               reduce using rule 43 (e -> ( e ) .)
    /               reduce using rule 43 (e -> ( e ) .)
    +               reduce using rule 43 (e -> ( e ) .)
    -               reduce using rule 43 (e -> ( e ) .)
    OR              reduce using rule 43 (e -> ( e ) .)
    AND             reduce using rule 43 (e -> ( e ) .)
    XOR             reduce using rule 43 (e -> ( e ) .)
    SMALLER         reduce using rule 43 (e -> ( e ) .)
    SMALLER_EQUAL   reduce using rule 43 (e -> ( e ) .)
    BIGGER          reduce using rule 43 (e -> ( e ) .)
    BIGGER_EQUAL    reduce using rule 43 (e -> ( e ) .)
    EQUAL           reduce using rule 43 (e -> ( e ) .)
    NOT_EQUAL       reduce using rule 43 (e -> ( e ) .)
    V               reduce using rule 43 (e -> ( e ) .)
    ESCREVER        reduce using rule 43 (e -> ( e ) .)
    ID              reduce using rule 43 (e -> ( e ) .)
    PARA            reduce using rule 43 (e -> ( e ) .)
    VAR             reduce using rule 43 (e -> ( e ) .)
    SE              reduce using rule 43 (e -> ( e ) .)
    FUNCAO          reduce using rule 43 (e -> ( e ) .)
    ;               reduce using rule 43 (e -> ( e ) .)
    FIM_SE          reduce using rule 43 (e -> ( e ) .)
    SENAO           reduce using rule 43 (e -> ( e ) .)
    FIM_FUNCAO      reduce using rule 43 (e -> ( e ) .)
    FIM             reduce using rule 43 (e -> ( e ) .)
    ENTAO           reduce using rule 43 (e -> ( e ) .)
    )               reduce using rule 43 (e -> ( e ) .)
    ,               reduce using rule 43 (e -> ( e ) .)


state 83

    (28) e_list -> e_list , . e
    (29) e -> . ID
    (30) e -> . REAL
    (31) e -> . INTEIRO
    (32) e -> . CARACTER
    (33) e -> . condicao
    (34) e -> . - e
    (35) e -> . e * e
    (36) e -> . e / e
    (37) e -> . e + e
    (38) e -> . e - e
    (39) e -> . logico
    (40) e -> . e OR e
    (41) e -> . e AND e
    (42) e -> . e XOR e
    (43) e -> . ( e )
    (44) condicao -> . e SMALLER e
    (45) condicao -> . e SMALLER_EQUAL e
    (46) condicao -> . e BIGGER e
    (47) condicao -> . e BIGGER_EQUAL e
    (48) condicao -> . e EQUAL e
    (49) condicao -> . e NOT_EQUAL e
    (54) logico -> . TRUE
    (55) logico -> . FALSE
    (56) logico -> . NOT logico

    ID              shift and go to state 22
    REAL            shift and go to state 23
    INTEIRO         shift and go to state 24
    CARACTER        shift and go to state 25
    -               shift and go to state 27
    (               shift and go to state 29
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    NOT             shift and go to state 33

    e                              shift and go to state 95
    condicao                       shift and go to state 26
    logico                         shift and go to state 28

state 84

    (15) ciclo_for -> PARA ID EM [ . INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM

    INTEIRO         shift and go to state 96


state 85

    (20) callfunc -> VAR ( e_list ) .

    ;               reduce using rule 20 (callfunc -> VAR ( e_list ) .)


state 86

    (16) if -> SE e ENTAO com_list . FIM_SE
    (17) if -> SE e ENTAO com_list . SENAO com_list FIM_SE
    (5) com_list -> com_list . command
    (6) command -> . V STRING ATRIBUICAO var_list
    (7) command -> . ESCREVER STRING ;
    (8) command -> . ESCREVER e
    (9) command -> . ESCREVER var_list
    (10) command -> . ID ATRIBUICAO e_list
    (11) command -> . ciclo_for
    (12) command -> . callfunc ;
    (13) command -> . if
    (14) command -> . func
    (15) ciclo_for -> . PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM
    (20) callfunc -> . VAR ( e_list )
    (21) callfunc -> . VAR ( )
    (16) if -> . SE e ENTAO com_list FIM_SE
    (17) if -> . SE e ENTAO com_list SENAO com_list FIM_SE
    (18) func -> . FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO
    (19) func -> . FUNCAO VAR ( ) com_list FIM_FUNCAO

    FIM_SE          shift and go to state 97
    SENAO           shift and go to state 98
    V               shift and go to state 5
    ESCREVER        shift and go to state 6
    ID              shift and go to state 7
    PARA            shift and go to state 12
    VAR             shift and go to state 13
    SE              shift and go to state 14
    FUNCAO          shift and go to state 15

    command                        shift and go to state 17
    ciclo_for                      shift and go to state 8
    callfunc                       shift and go to state 9
    if                             shift and go to state 10
    func                           shift and go to state 11

state 87

    (18) func -> FUNCAO VAR ( var_fun_list . ) com_list FIM_FUNCAO
    (23) var_fun_list -> var_fun_list . , var_fun

    )               shift and go to state 99
    ,               shift and go to state 100


state 88

    (19) func -> FUNCAO VAR ( ) . com_list FIM_FUNCAO
    (4) com_list -> . command
    (5) com_list -> . com_list command
    (6) command -> . V STRING ATRIBUICAO var_list
    (7) command -> . ESCREVER STRING ;
    (8) command -> . ESCREVER e
    (9) command -> . ESCREVER var_list
    (10) command -> . ID ATRIBUICAO e_list
    (11) command -> . ciclo_for
    (12) command -> . callfunc ;
    (13) command -> . if
    (14) command -> . func
    (15) ciclo_for -> . PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM
    (20) callfunc -> . VAR ( e_list )
    (21) callfunc -> . VAR ( )
    (16) if -> . SE e ENTAO com_list FIM_SE
    (17) if -> . SE e ENTAO com_list SENAO com_list FIM_SE
    (18) func -> . FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO
    (19) func -> . FUNCAO VAR ( ) com_list FIM_FUNCAO

    V               shift and go to state 5
    ESCREVER        shift and go to state 6
    ID              shift and go to state 7
    PARA            shift and go to state 12
    VAR             shift and go to state 13
    SE              shift and go to state 14
    FUNCAO          shift and go to state 15

    com_list                       shift and go to state 101
    command                        shift and go to state 3
    ciclo_for                      shift and go to state 8
    callfunc                       shift and go to state 9
    if                             shift and go to state 10
    func                           shift and go to state 11

state 89

    (22) var_fun_list -> var_fun .

    )               reduce using rule 22 (var_fun_list -> var_fun .)
    ,               reduce using rule 22 (var_fun_list -> var_fun .)


state 90

    (24) var_fun -> type . VAR

    VAR             shift and go to state 102


state 91

    (50) type -> DEFINITION_INTEIRO .

    VAR             reduce using rule 50 (type -> DEFINITION_INTEIRO .)


state 92

    (51) type -> DEFINITION_REAL .

    VAR             reduce using rule 51 (type -> DEFINITION_REAL .)


state 93

    (52) type -> DEFINITION_CARACTER .

    VAR             reduce using rule 52 (type -> DEFINITION_CARACTER .)


state 94

    (53) type -> DEFENITION_LOGICO .

    VAR             reduce using rule 53 (type -> DEFENITION_LOGICO .)


state 95

    (28) e_list -> e_list , e .
    (35) e -> e . * e
    (36) e -> e . / e
    (37) e -> e . + e
    (38) e -> e . - e
    (40) e -> e . OR e
    (41) e -> e . AND e
    (42) e -> e . XOR e
    (44) condicao -> e . SMALLER e
    (45) condicao -> e . SMALLER_EQUAL e
    (46) condicao -> e . BIGGER e
    (47) condicao -> e . BIGGER_EQUAL e
    (48) condicao -> e . EQUAL e
    (49) condicao -> e . NOT_EQUAL e

    ,               reduce using rule 28 (e_list -> e_list , e .)
    V               reduce using rule 28 (e_list -> e_list , e .)
    ESCREVER        reduce using rule 28 (e_list -> e_list , e .)
    ID              reduce using rule 28 (e_list -> e_list , e .)
    PARA            reduce using rule 28 (e_list -> e_list , e .)
    VAR             reduce using rule 28 (e_list -> e_list , e .)
    SE              reduce using rule 28 (e_list -> e_list , e .)
    FUNCAO          reduce using rule 28 (e_list -> e_list , e .)
    ;               reduce using rule 28 (e_list -> e_list , e .)
    FIM_SE          reduce using rule 28 (e_list -> e_list , e .)
    SENAO           reduce using rule 28 (e_list -> e_list , e .)
    FIM_FUNCAO      reduce using rule 28 (e_list -> e_list , e .)
    FIM             reduce using rule 28 (e_list -> e_list , e .)
    )               reduce using rule 28 (e_list -> e_list , e .)
    *               shift and go to state 43
    /               shift and go to state 44
    +               shift and go to state 45
    -               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    XOR             shift and go to state 49
    SMALLER         shift and go to state 50
    SMALLER_EQUAL   shift and go to state 51
    BIGGER          shift and go to state 52
    BIGGER_EQUAL    shift and go to state 53
    EQUAL           shift and go to state 54
    NOT_EQUAL       shift and go to state 55


state 96

    (15) ciclo_for -> PARA ID EM [ INTEIRO . ELIPSIS INTEIRO ] FAZER com_list FIM

    ELIPSIS         shift and go to state 103


state 97

    (16) if -> SE e ENTAO com_list FIM_SE .

    V               reduce using rule 16 (if -> SE e ENTAO com_list FIM_SE .)
    ESCREVER        reduce using rule 16 (if -> SE e ENTAO com_list FIM_SE .)
    ID              reduce using rule 16 (if -> SE e ENTAO com_list FIM_SE .)
    PARA            reduce using rule 16 (if -> SE e ENTAO com_list FIM_SE .)
    VAR             reduce using rule 16 (if -> SE e ENTAO com_list FIM_SE .)
    SE              reduce using rule 16 (if -> SE e ENTAO com_list FIM_SE .)
    FUNCAO          reduce using rule 16 (if -> SE e ENTAO com_list FIM_SE .)
    ;               reduce using rule 16 (if -> SE e ENTAO com_list FIM_SE .)
    FIM_SE          reduce using rule 16 (if -> SE e ENTAO com_list FIM_SE .)
    SENAO           reduce using rule 16 (if -> SE e ENTAO com_list FIM_SE .)
    FIM_FUNCAO      reduce using rule 16 (if -> SE e ENTAO com_list FIM_SE .)
    FIM             reduce using rule 16 (if -> SE e ENTAO com_list FIM_SE .)


state 98

    (17) if -> SE e ENTAO com_list SENAO . com_list FIM_SE
    (4) com_list -> . command
    (5) com_list -> . com_list command
    (6) command -> . V STRING ATRIBUICAO var_list
    (7) command -> . ESCREVER STRING ;
    (8) command -> . ESCREVER e
    (9) command -> . ESCREVER var_list
    (10) command -> . ID ATRIBUICAO e_list
    (11) command -> . ciclo_for
    (12) command -> . callfunc ;
    (13) command -> . if
    (14) command -> . func
    (15) ciclo_for -> . PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM
    (20) callfunc -> . VAR ( e_list )
    (21) callfunc -> . VAR ( )
    (16) if -> . SE e ENTAO com_list FIM_SE
    (17) if -> . SE e ENTAO com_list SENAO com_list FIM_SE
    (18) func -> . FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO
    (19) func -> . FUNCAO VAR ( ) com_list FIM_FUNCAO

    V               shift and go to state 5
    ESCREVER        shift and go to state 6
    ID              shift and go to state 7
    PARA            shift and go to state 12
    VAR             shift and go to state 13
    SE              shift and go to state 14
    FUNCAO          shift and go to state 15

    com_list                       shift and go to state 104
    command                        shift and go to state 3
    ciclo_for                      shift and go to state 8
    callfunc                       shift and go to state 9
    if                             shift and go to state 10
    func                           shift and go to state 11

state 99

    (18) func -> FUNCAO VAR ( var_fun_list ) . com_list FIM_FUNCAO
    (4) com_list -> . command
    (5) com_list -> . com_list command
    (6) command -> . V STRING ATRIBUICAO var_list
    (7) command -> . ESCREVER STRING ;
    (8) command -> . ESCREVER e
    (9) command -> . ESCREVER var_list
    (10) command -> . ID ATRIBUICAO e_list
    (11) command -> . ciclo_for
    (12) command -> . callfunc ;
    (13) command -> . if
    (14) command -> . func
    (15) ciclo_for -> . PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM
    (20) callfunc -> . VAR ( e_list )
    (21) callfunc -> . VAR ( )
    (16) if -> . SE e ENTAO com_list FIM_SE
    (17) if -> . SE e ENTAO com_list SENAO com_list FIM_SE
    (18) func -> . FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO
    (19) func -> . FUNCAO VAR ( ) com_list FIM_FUNCAO

    V               shift and go to state 5
    ESCREVER        shift and go to state 6
    ID              shift and go to state 7
    PARA            shift and go to state 12
    VAR             shift and go to state 13
    SE              shift and go to state 14
    FUNCAO          shift and go to state 15

    com_list                       shift and go to state 105
    command                        shift and go to state 3
    ciclo_for                      shift and go to state 8
    callfunc                       shift and go to state 9
    if                             shift and go to state 10
    func                           shift and go to state 11

state 100

    (23) var_fun_list -> var_fun_list , . var_fun
    (24) var_fun -> . type VAR
    (50) type -> . DEFINITION_INTEIRO
    (51) type -> . DEFINITION_REAL
    (52) type -> . DEFINITION_CARACTER
    (53) type -> . DEFENITION_LOGICO

    DEFINITION_INTEIRO shift and go to state 91
    DEFINITION_REAL shift and go to state 92
    DEFINITION_CARACTER shift and go to state 93
    DEFENITION_LOGICO shift and go to state 94

    var_fun                        shift and go to state 106
    type                           shift and go to state 90

state 101

    (19) func -> FUNCAO VAR ( ) com_list . FIM_FUNCAO
    (5) com_list -> com_list . command
    (6) command -> . V STRING ATRIBUICAO var_list
    (7) command -> . ESCREVER STRING ;
    (8) command -> . ESCREVER e
    (9) command -> . ESCREVER var_list
    (10) command -> . ID ATRIBUICAO e_list
    (11) command -> . ciclo_for
    (12) command -> . callfunc ;
    (13) command -> . if
    (14) command -> . func
    (15) ciclo_for -> . PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM
    (20) callfunc -> . VAR ( e_list )
    (21) callfunc -> . VAR ( )
    (16) if -> . SE e ENTAO com_list FIM_SE
    (17) if -> . SE e ENTAO com_list SENAO com_list FIM_SE
    (18) func -> . FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO
    (19) func -> . FUNCAO VAR ( ) com_list FIM_FUNCAO

    FIM_FUNCAO      shift and go to state 107
    V               shift and go to state 5
    ESCREVER        shift and go to state 6
    ID              shift and go to state 7
    PARA            shift and go to state 12
    VAR             shift and go to state 13
    SE              shift and go to state 14
    FUNCAO          shift and go to state 15

    command                        shift and go to state 17
    ciclo_for                      shift and go to state 8
    callfunc                       shift and go to state 9
    if                             shift and go to state 10
    func                           shift and go to state 11

state 102

    (24) var_fun -> type VAR .

    )               reduce using rule 24 (var_fun -> type VAR .)
    ,               reduce using rule 24 (var_fun -> type VAR .)


state 103

    (15) ciclo_for -> PARA ID EM [ INTEIRO ELIPSIS . INTEIRO ] FAZER com_list FIM

    INTEIRO         shift and go to state 108


state 104

    (17) if -> SE e ENTAO com_list SENAO com_list . FIM_SE
    (5) com_list -> com_list . command
    (6) command -> . V STRING ATRIBUICAO var_list
    (7) command -> . ESCREVER STRING ;
    (8) command -> . ESCREVER e
    (9) command -> . ESCREVER var_list
    (10) command -> . ID ATRIBUICAO e_list
    (11) command -> . ciclo_for
    (12) command -> . callfunc ;
    (13) command -> . if
    (14) command -> . func
    (15) ciclo_for -> . PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM
    (20) callfunc -> . VAR ( e_list )
    (21) callfunc -> . VAR ( )
    (16) if -> . SE e ENTAO com_list FIM_SE
    (17) if -> . SE e ENTAO com_list SENAO com_list FIM_SE
    (18) func -> . FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO
    (19) func -> . FUNCAO VAR ( ) com_list FIM_FUNCAO

    FIM_SE          shift and go to state 109
    V               shift and go to state 5
    ESCREVER        shift and go to state 6
    ID              shift and go to state 7
    PARA            shift and go to state 12
    VAR             shift and go to state 13
    SE              shift and go to state 14
    FUNCAO          shift and go to state 15

    command                        shift and go to state 17
    ciclo_for                      shift and go to state 8
    callfunc                       shift and go to state 9
    if                             shift and go to state 10
    func                           shift and go to state 11

state 105

    (18) func -> FUNCAO VAR ( var_fun_list ) com_list . FIM_FUNCAO
    (5) com_list -> com_list . command
    (6) command -> . V STRING ATRIBUICAO var_list
    (7) command -> . ESCREVER STRING ;
    (8) command -> . ESCREVER e
    (9) command -> . ESCREVER var_list
    (10) command -> . ID ATRIBUICAO e_list
    (11) command -> . ciclo_for
    (12) command -> . callfunc ;
    (13) command -> . if
    (14) command -> . func
    (15) ciclo_for -> . PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM
    (20) callfunc -> . VAR ( e_list )
    (21) callfunc -> . VAR ( )
    (16) if -> . SE e ENTAO com_list FIM_SE
    (17) if -> . SE e ENTAO com_list SENAO com_list FIM_SE
    (18) func -> . FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO
    (19) func -> . FUNCAO VAR ( ) com_list FIM_FUNCAO

    FIM_FUNCAO      shift and go to state 110
    V               shift and go to state 5
    ESCREVER        shift and go to state 6
    ID              shift and go to state 7
    PARA            shift and go to state 12
    VAR             shift and go to state 13
    SE              shift and go to state 14
    FUNCAO          shift and go to state 15

    command                        shift and go to state 17
    ciclo_for                      shift and go to state 8
    callfunc                       shift and go to state 9
    if                             shift and go to state 10
    func                           shift and go to state 11

state 106

    (23) var_fun_list -> var_fun_list , var_fun .

    )               reduce using rule 23 (var_fun_list -> var_fun_list , var_fun .)
    ,               reduce using rule 23 (var_fun_list -> var_fun_list , var_fun .)


state 107

    (19) func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .

    V               reduce using rule 19 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    ESCREVER        reduce using rule 19 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    ID              reduce using rule 19 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    PARA            reduce using rule 19 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    VAR             reduce using rule 19 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    SE              reduce using rule 19 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    FUNCAO          reduce using rule 19 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    ;               reduce using rule 19 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    FIM_SE          reduce using rule 19 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    SENAO           reduce using rule 19 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    FIM_FUNCAO      reduce using rule 19 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)
    FIM             reduce using rule 19 (func -> FUNCAO VAR ( ) com_list FIM_FUNCAO .)


state 108

    (15) ciclo_for -> PARA ID EM [ INTEIRO ELIPSIS INTEIRO . ] FAZER com_list FIM

    ]               shift and go to state 111


state 109

    (17) if -> SE e ENTAO com_list SENAO com_list FIM_SE .

    V               reduce using rule 17 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    ESCREVER        reduce using rule 17 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    ID              reduce using rule 17 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    PARA            reduce using rule 17 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    VAR             reduce using rule 17 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    SE              reduce using rule 17 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    FUNCAO          reduce using rule 17 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    ;               reduce using rule 17 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    FIM_SE          reduce using rule 17 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    SENAO           reduce using rule 17 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    FIM_FUNCAO      reduce using rule 17 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)
    FIM             reduce using rule 17 (if -> SE e ENTAO com_list SENAO com_list FIM_SE .)


state 110

    (18) func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .

    V               reduce using rule 18 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    ESCREVER        reduce using rule 18 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    ID              reduce using rule 18 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    PARA            reduce using rule 18 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    VAR             reduce using rule 18 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    SE              reduce using rule 18 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    FUNCAO          reduce using rule 18 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    ;               reduce using rule 18 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    FIM_SE          reduce using rule 18 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    SENAO           reduce using rule 18 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    FIM_FUNCAO      reduce using rule 18 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)
    FIM             reduce using rule 18 (func -> FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO .)


state 111

    (15) ciclo_for -> PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] . FAZER com_list FIM

    FAZER           shift and go to state 112


state 112

    (15) ciclo_for -> PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER . com_list FIM
    (4) com_list -> . command
    (5) com_list -> . com_list command
    (6) command -> . V STRING ATRIBUICAO var_list
    (7) command -> . ESCREVER STRING ;
    (8) command -> . ESCREVER e
    (9) command -> . ESCREVER var_list
    (10) command -> . ID ATRIBUICAO e_list
    (11) command -> . ciclo_for
    (12) command -> . callfunc ;
    (13) command -> . if
    (14) command -> . func
    (15) ciclo_for -> . PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM
    (20) callfunc -> . VAR ( e_list )
    (21) callfunc -> . VAR ( )
    (16) if -> . SE e ENTAO com_list FIM_SE
    (17) if -> . SE e ENTAO com_list SENAO com_list FIM_SE
    (18) func -> . FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO
    (19) func -> . FUNCAO VAR ( ) com_list FIM_FUNCAO

    V               shift and go to state 5
    ESCREVER        shift and go to state 6
    ID              shift and go to state 7
    PARA            shift and go to state 12
    VAR             shift and go to state 13
    SE              shift and go to state 14
    FUNCAO          shift and go to state 15

    com_list                       shift and go to state 113
    command                        shift and go to state 3
    ciclo_for                      shift and go to state 8
    callfunc                       shift and go to state 9
    if                             shift and go to state 10
    func                           shift and go to state 11

state 113

    (15) ciclo_for -> PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list . FIM
    (5) com_list -> com_list . command
    (6) command -> . V STRING ATRIBUICAO var_list
    (7) command -> . ESCREVER STRING ;
    (8) command -> . ESCREVER e
    (9) command -> . ESCREVER var_list
    (10) command -> . ID ATRIBUICAO e_list
    (11) command -> . ciclo_for
    (12) command -> . callfunc ;
    (13) command -> . if
    (14) command -> . func
    (15) ciclo_for -> . PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM
    (20) callfunc -> . VAR ( e_list )
    (21) callfunc -> . VAR ( )
    (16) if -> . SE e ENTAO com_list FIM_SE
    (17) if -> . SE e ENTAO com_list SENAO com_list FIM_SE
    (18) func -> . FUNCAO VAR ( var_fun_list ) com_list FIM_FUNCAO
    (19) func -> . FUNCAO VAR ( ) com_list FIM_FUNCAO

    FIM             shift and go to state 114
    V               shift and go to state 5
    ESCREVER        shift and go to state 6
    ID              shift and go to state 7
    PARA            shift and go to state 12
    VAR             shift and go to state 13
    SE              shift and go to state 14
    FUNCAO          shift and go to state 15

    command                        shift and go to state 17
    ciclo_for                      shift and go to state 8
    callfunc                       shift and go to state 9
    if                             shift and go to state 10
    func                           shift and go to state 11

state 114

    (15) ciclo_for -> PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .

    V               reduce using rule 15 (ciclo_for -> PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    ESCREVER        reduce using rule 15 (ciclo_for -> PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    ID              reduce using rule 15 (ciclo_for -> PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    PARA            reduce using rule 15 (ciclo_for -> PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    VAR             reduce using rule 15 (ciclo_for -> PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    SE              reduce using rule 15 (ciclo_for -> PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    FUNCAO          reduce using rule 15 (ciclo_for -> PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    ;               reduce using rule 15 (ciclo_for -> PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    FIM_SE          reduce using rule 15 (ciclo_for -> PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    SENAO           reduce using rule 15 (ciclo_for -> PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    FIM_FUNCAO      reduce using rule 15 (ciclo_for -> PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)
    FIM             reduce using rule 15 (ciclo_for -> PARA ID EM [ INTEIRO ELIPSIS INTEIRO ] FAZER com_list FIM .)

